import re 
import collections
import collections.abc 
from ChatBotTrainMixed import compare_ticket_prices 
collections.Mapping = collections.abc.Mapping
collections.Sequence = collections.abc.Sequence
collections.Iterable = collections.abc.Iterable
from experta import KnowledgeEngine, Rule, Fact, MATCH  
from fuzzywuzzy import fuzz 
import sqlite3  
import random 
import pandas as pd 
import nltk 
from nltk.stem import PorterStemmer, WordNetLemmatizer  
from nltk.corpus import stopwords 
from typing import Dict, List, Optional, Tuple 
import spacy 
from spacy.matcher import Matcher  
from selenium import webdriver  
from selenium.webdriver.common.by import By  
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC  
from urllib.parse import urlencode 
from datetime import datetime, timedelta 
import time 
from dateutil.parser import parse 
from sklearn.ensemble import RandomForestRegressor  
from sklearn.model_selection import train_test_split 
from sklearn.metrics import mean_absolute_error  
import numpy as np
import json


with open("qna_kb.json") as f:
    qa_kb = json.load(f)

# Initialize spaCy for NLP
try:
# NLP Model Initialization 
    nlp = spacy.load('en_core_web_sm')
    print("NLP model loaded successfully.")  # Debug/logging output
except:
    print("spaCy not available. Some features will be limited.")  # Debug/logging output
    nlp = None



# RandomForestDelayPredictor: ML Model for Delay Prediction
class RandomForestDelayPredictor:
    #Random Forest delay predictor with dynamic station handling

    def __init__(self, station_sequences):
        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42
        )
        self.station_sequences = station_sequences
        self.station_to_idx = self._create_station_mapping()
        self.is_trained = False
        self.feature_names = ['day_of_week', 'hour_of_day', 'station_idx', 'route_type']

    def _create_station_mapping(self):
#Create dynamic station index mapping
        station_map = {}
        for route, stations in self.station_sequences.items():
            for idx, station in enumerate(stations):
                station_map[(route, station)] = idx
        return station_map  # Return result

    def preprocess_data(self, df):
        #Prepare data with dynamic station handling
        # Make a copy to avoid Warning
        df = df.copy()

        # Convert times to datetime 
        if 'planned_departure' in df.columns and not pd.api.types.is_datetime64_any_dtype(df['planned_departure']):
            try:
                df['planned_departure'] = pd.to_datetime(df['planned_departure'], errors='coerce')
            except:
                pass

        # Calculate delay if not already presents
        if 'delay_minutes' not in df.columns and 'planned_departure' in df.columns and 'actual_departure' in df.columns:
            df['delay_minutes'] = (
                    (df['actual_departure'] - df['planned_departure']).dt.total_seconds() / 60
            )

        # Add station position for each route
        df['station_idx'] = df.apply(
            lambda x: self.station_to_idx.get((x['route'], x['location']), -1),
            axis=1
        )

        # Feature engineering
        df['day_of_week'] = df['planned_departure'].dt.dayofweek
        df['hour_of_day'] = df['planned_departure'].dt.hour
        df['route_type'] = df['route'].map({
            'Norwich-LST': 0,
            'LST-Norwich': 1
        })

        # Drop rows with missing data
        df = df.dropna(subset=['delay_minutes', 'station_idx'])

        return df  # Return result

#training model
    def train(self, df):
        processed = self.preprocess_data(df)
        X = processed[self.feature_names]
        y = processed['delay_minutes']
        X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)
        self.model.fit(X_train, y_train)
        self.is_trained = True
        preds = self.model.predict(X_val)
        mae = mean_absolute_error(y_val, preds)
        print(f"Model trained on {len(X_train)} samples. Validation MAE: {mae:.2f} minutes")  # Debugt


    def predict(self, route, current_station):
        #Make prediction using current conditions
        if not self.is_trained:
            raise ValueError("Model not trained yet")

        station_idx = self.station_to_idx.get((route, current_station), -1)
        if station_idx == -1:
            return None  # Return result

        # standardize the features
        input_features = pd.DataFrame([{
            'day_of_week': datetime.now().weekday(),
            'hour_of_day': datetime.now().hour,
            'station_idx': station_idx,
            'route_type': 0 if route == 'Norwich-LST' else 1
        }])[self.feature_names]  # Ensure same column order as training

        return float(self.model.predict(input_features)[0])  # Return result



#rule based engined
class DelayReasoningEngine(KnowledgeEngine):

    def __init__(self, station_sequences, delay_stats):
        super().__init__()
        self.station_sequences = station_sequences
        self.delay_stats = delay_stats

    @Rule(Fact(route=MATCH.r),
          Fact(current_station=MATCH.s),
          Fact(reported_delay=MATCH.d))

    def predict_delay(self, r, s, d):
        # Calculate cumulative delay using rules
        stations = self.station_sequences[r]
        current_idx = stations.index(s)
        total_delay = float(d)

        # Add median delays between current station and destination
        for i in range(current_idx, len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)
            if pair in self.delay_stats:
                total_delay += self.delay_stats[pair]['median_delay']

        self.declare(Fact(predicted_delay=total_delay))



#  TrainTicketChatbotWithBooking: Main Chatbot Class 
#reasoning engine
class GeneralRuleEngine(KnowledgeEngine):

    @Rule(Fact(topic="refund"), Fact(condition="missed_train"))
    def handle_missed_train_refund(self):
        self.declare(Fact(response="If you missed your train, check if your ticket is flexible or refundable."))

    @Rule(Fact(topic="bike"))
    def handle_bike_policy(self):
        self.declare(Fact(response="Folding bikes are allowed anytime. Standard bikes are allowed off-peak."))


class TrainTicketChatbotWithBooking:


    def __init__(self):
        #nlp stemmong and lemmatization initalization
        self.stemmer = PorterStemmer()
        self.lemmatizer = WordNetLemmatizer()
        self.stop_words = set(nltk.corpus.stopwords.words('english'))
        self.greetings = [
            "Hello! I'm TrainBot, how can I help with your train journey today?",
            "Hi there! How can I assist with your train travel?"
        ]
        #defaults states for booking
        self.farewells = ["Thank you for using our service. Safe travels!"]
        self.options_prompt = "What would you like to do today? You can:\n1. Book tickets\n2. Check for delays\n3. Ask any other questions\n4. Exit"
        self.STATES = {
            'GREETING': 0,
            'GET_OPTION': 1,
            'PARSE_BOOKING': 2,
            'GET_MISSING_INFO': 3,
            'CONFIRM_BOOKING': 4,
            'FAREWELL': 5,
            'DELAY_INQUIRY': 6,
            'GET_CURRENT_STATION': 7,
            'GET_DELAY_DURATION': 8,
            'GET_DESTINATION': 9,
            'ASK_RETURN': 10
        }
        #defaults 1 adults for booking ticket
        self.current_state = self.STATES['GREETING']
        self.booking_details = {
            'origin': None,
            'destination': None,
            'date': None,
            'time': None,
            'adults': '1',
            'children': '0',
            'confirmed': False,
            'is_return': False
        }
        #initalize all fields and csv files
        self.missing_fields = []
        self.stations = []
        self.station_codes = {}
        self.load_station_data('stations.csv')
        self.db_conn = sqlite3.connect(':memory:', check_same_thread=False)
        self.create_tables()
        self.load_delay_data()
        self.delay_engine = DelayReasoningEngine(
            station_sequences=self.station_sequences,
            delay_stats=self.delay_stats
        )
        self.delay_predictor = RandomForestDelayPredictor(
            station_sequences=self.station_sequences
        )
        self._train_delay_model()
        self.delay_details = {}
        self.normal_travel_times = {}
        for route in self.station_sequences:
            self.normal_travel_times[route] = self.calculate_normal_travel_times(route)



    def load_delay_data(self):
        #load and process delay data from CSV files
        self.delay_data = {
            'Norwich-LST': [],
            'LST-Norwich': []
        }

        # Load data for Norwich to London route
        for year in [2022, 2023, 2024]:
            try:
                df = pd.read_csv(f'{year}_service_details_Norwich_to_London.csv')
                df['route'] = 'Norwich-LST'
                self.delay_data['Norwich-LST'].append(df)
            except FileNotFoundError:
                print(f"Warning: {year}_service_details_Norwich_to_London.csv not found")  # Debug/logging output

        # Load data for London to Norwich route
        for year in [2022, 2023, 2024]:
            try:
                df = pd.read_csv(f'{year}_service_details_London_to_Norwich.csv')
                df['route'] = 'LST-Norwich'
                self.delay_data['LST-Norwich'].append(df)
            except FileNotFoundError:
                print(f"Warning: {year}_service_details_London_to_Norwich.csv not found")  # Debug/logging output

        # Combine all data for each route
        for route in self.delay_data:
            if self.delay_data[route]:
                self.delay_data[route] = pd.concat(self.delay_data[route])
                print(f"Loaded {len(self.delay_data[route])} records for {route} route")  # Debug/logging output

        # Extract station sequences from the data
        self.extract_station_sequences()
        self.preprocess_delay_data()
        self.expecting_return_time = False



    def extract_station_sequences(self):
        #Properly extract station sequences from CSV files
        self.station_sequences = {'Norwich-LST': [], 'LST-Norwich': []}

        # Process Norwich to London file
        if isinstance(self.delay_data['Norwich-LST'], pd.DataFrame):
            df = self.delay_data['Norwich-LST']
            # Group by train ID and get unique station order
            sequences = df.groupby('rid').apply(
                lambda x: x.sort_values('planned_departure_time')['location'].unique().tolist()
            )
            if len(sequences) > 0:
                self.station_sequences['Norwich-LST'] = sequences.iloc[0]  # Take first sequence

        # Process London to Norwich file
        if isinstance(self.delay_data['LST-Norwich'], pd.DataFrame):
            df = self.delay_data['LST-Norwich']
            # Group by train ID and get unique station order
            sequences = df.groupby('rid').apply(
                lambda x: x.sort_values('gbtt_ptd')['location'].unique().tolist()
            )
            if len(sequences) > 0:
                self.station_sequences['LST-Norwich'] = sequences.iloc[0]  # Take first sequence

        print(f"Final station sequences: {self.station_sequences}")  # Debug logging output


    def preprocess_text(self, text: str) -> List[str]:
        #Enhanced text preprocessing with stemming and lemmatizatio
        try:
            # Tokenize and lowercase
            tokens = nltk.word_tokenize(text.lower())

            # Remove stopwords and punctuation
            tokens = [token for token in tokens
                      if token not in self.stop_words and token.isalpha()]

            processed_tokens = []
            for token in tokens:
                try:
                    # Lemmatize first 
                    lemma = self.lemmatizer.lemmatize(token)
                    # Then stem 
                    stem = self.stemmer.stem(lemma)

                    # Use stem if it's significantly shorter, else use lemma
                    if len(stem) < len(lemma) - 1:
                        processed_tokens.append(stem)
                    else:
                        processed_tokens.append(lemma)
                except:
                    processed_tokens.append(token)

            return processed_tokens  # Return result
        except Exception as e:
            print(f"Error preprocessing text: {e}")  # Debug
            return []  # Return result



    def parse_date(self, date_str: str, relative_base: Optional[str] = None) -> Optional[str]:
        try:
            date_str = date_str.lower().strip()
            date_str = re.sub(r'\b(on|the|of)\b', ' ', date_str, flags=re.IGNORECASE)
            date_str = re.sub(r'(\d+)(h)\b', r'\1th', date_str, flags=re.IGNORECASE)
            date_str = ' '.join(date_str.split())

            today = datetime.now().date()

            # Handle simple relative expressions like today and tomorrow
            if date_str in ['today']:
                return today.strftime('%d/%m/%Y')
            elif date_str == 'tomorrow':
                return (today + timedelta(days=1)).strftime('%d/%m/%Y')
            elif date_str == 'day after tomorrow':
                return (today + timedelta(days=2)).strftime('%d/%m/%Y')
            elif date_str == 'next week':
                return (today + timedelta(weeks=1)).strftime('%d/%m/%Y')
            elif date_str == 'next month':
                next_month = today.replace(day=1) + timedelta(days=32)
                return next_month.replace(day=min(today.day, 28)).strftime('%d/%m/%Y')
            elif re.match(r'in\s+(\d+)\s*weeks?', date_str):
                num = int(re.findall(r'\d+', date_str)[0])
                return (today + timedelta(weeks=num)).strftime('%d/%m/%Y')
            elif re.match(r'in\s+(\d+)\s*days?', date_str):
                num = int(re.findall(r'\d+', date_str)[0])
                return (today + timedelta(days=num)).strftime('%d/%m/%Y')

            # Handle next week
            if date_str.startswith("next "):
                weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                day_name = date_str[5:]
                if day_name in weekdays:
                    days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                    if days_ahead == 0:
                        days_ahead = 7
                    return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')

            # Handle relateive times
            match = re.search(r'(\d+)\s*(day|days|week|weeks)\s*(later|after)', date_str)
            if match:
                num = int(match.group(1))
                unit = match.group(2)
                base_date = datetime.strptime(relative_base, '%d/%m/%Y') if relative_base else today
                if 'week' in unit:
                    return (base_date + timedelta(weeks=num)).strftime('%d/%m/%Y')
                else:
                    return (base_date + timedelta(days=num)).strftime('%d/%m/%Y')

            # Try natural language formats (e.g., "15th July", "July 15")
            patterns = [
                r'(\d{1,2})(?:st|nd|rd|th)?\s*([A-Za-z]+)(?:\s*(\d{4}))?',  # Day-first
                r'([A-Za-z]+)\s*(\d{1,2})(?:st|nd|rd|th)?(?:\s*(\d{4}))?'   # Month-first
            ]
            for pattern in patterns:
                match = re.search(pattern, date_str)
                if match:
                    if pattern.startswith(r'(\d{1,2})'):
                        day, month, year = match.groups()
                    else:
                        month, day, year = match.groups()
#months are mapped here

                    month_map = {
                        'january': '01', 'jan': '01',
                        'february': '02', 'feb': '02',
                        'march': '03', 'mar': '03',
                        'april': '04', 'apr': '04',
                        'may': '05',
                        'june': '06', 'jun': '06',
                        'july': '07', 'jul': '07',
                        'august': '08', 'aug': '08',
                        'september': '09', 'sep': '09',
                        'october': '10', 'oct': '10',
                        'november': '11', 'nov': '11',
                        'december': '12', 'dec': '12'
                    }
                    month_num = month_map.get(month.lower())
                    if not month_num:
                        continue
                    year = year or str(today.year)
                    return f"{day.zfill(2)}/{month_num}/{year}"

            # Final fallback to dateutil
            try:
                dt = parse(date_str, fuzzy=True, dayfirst=True)
                return dt.strftime('%d/%m/%Y')
            except Exception:
                return None

        except Exception as e:
            print(f"[ERROR] parse_date failed: {str(e)}")
            return None


    def _train_delay_model(self):
        #Train model with all available data
        try:
            # Combine data from both routes norwich to london and london to norwich
            combined_data = pd.concat([
                self.delay_data['Norwich-LST'],
                self.delay_data['LST-Norwich']
            ], ignore_index=True)

            print("\nColumns available for training:", combined_data.columns.tolist())  # Debug

            # Check if there is enough data
            if len(combined_data) < 100:
                raise ValueError(f"Not enough training data (only {len(combined_data)} samples)")

            # Train the model
            self.delay_predictor.train(combined_data)
            print("Random Forest model trained successfully")  # Debug

        except Exception as e:
            print(f"\nError training Random Forest model: {str(e)}")  # Debug
            print("Will use rule-based predictions only")  # Debug
            self.delay_predictor.is_trained = False


    def preprocess_delay_data(self):
        #Clean and prepare delay data for analysis
        for route in self.delay_data:
            if isinstance(self.delay_data[route], pd.DataFrame):
                df = self.delay_data[route].copy()
                time_cols = ['planned_arrival', 'planned_departure', 'actual_arrival', 'actual_departure']
                for col in time_cols:
                    if col in df:
                        df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time
            # Standardize column names across both routes
            if route == 'Norwich-LST':
                # Rename columns to standard names
                column_map = {
                    'planned_arrival_time': 'planned_arrival',
                    'planned_departure_time': 'planned_departure',
                    'actual_arrival_time': 'actual_arrival',
                    'actual_departure_time': 'actual_departure'
                }
                df = df.rename(columns={k: v for k, v in column_map.items() if k in df.columns})

                # Remove duplicate column if exists
                if 'late_canc_reason.1' in df.columns:
                    df = df.drop(columns=['late_canc_reason.1'])

            elif route == 'LST-Norwich':
                # Rename columns to standard names
                column_map = {
                    'gbtt_pta': 'planned_arrival',
                    'gbtt_ptd': 'planned_departure',
                    'actual_ta': 'actual_arrival',
                    'actual_td': 'actual_departure'
                }
                df = df.rename(columns={k: v for k, v in column_map.items() if k in df.columns})

            # Ensure if ther is  the required columns
            required_cols = ['planned_departure', 'actual_departure', 'location']
            missing_cols = [col for col in required_cols if col not in df.columns]
            if missing_cols:
                print(f"Warning: Missing columns in {route} data: {missing_cols}")  # Debug
                continue

            # Convert time columns to datetime.time
            time_cols = ['planned_arrival', 'planned_departure', 'actual_arrival', 'actual_departure']
            for col in time_cols:
                if col in df:
                    # Handle empty strings by replacing them with NaNs first
                    df[col] = df[col].replace('', pd.NA)
                    try:
                        df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time
                    except:
                        # Try different format if %H:%M fails
                        try:
                            df[col] = pd.to_datetime(df[col], format='%H:%M:%S', errors='coerce').dt.time
                        except:
                            df[col] = pd.NA

            # Calculate delay minutes (departure delay)
            df['delay_minutes'] = 0
            mask = df['actual_departure'].notna() & df['planned_departure'].notna()

            # Calculate delay in minutes
            df.loc[mask, 'delay_minutes'] = df[mask].apply(
                lambda x: (datetime.combine(datetime.today(), x['actual_departure']) -
                           datetime.combine(datetime.today(), x['planned_departure'])).total_seconds() / 60,
                axis=1
            )

            # Filter out extreme delays (more than 120 minutes)
            df = df[df['delay_minutes'].abs() <= 120]

            # Update the dataframe in delay_data
            self.delay_data[route] = df

            # Calculate typical delays between stations
            self.calculate_typical_delays(route, df)





    def calculate_typical_delays(self, route, df):
        #alculate typical delays between stations for a route
        if route not in self.station_sequences:
            return

        stations = self.station_sequences[route]
        delay_stats = {}

        for i in range(len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)

            # Get all services that stopped at both stations
            from_df = df[df['location'] == from_stn]
            to_df = df[df['location'] == to_stn]

            # Merge on rid and date_of_service to match the same train
            merged = pd.merge(
                from_df[['rid', 'date_of_service', 'actual_departure', 'delay_minutes']],
                to_df[['rid', 'date_of_service', 'actual_arrival', 'delay_minutes']],
                on=['rid', 'date_of_service'],
                suffixes=('_from', '_to')
            )

            if not merged.empty:
                # Calculate additional delay between stations
                merged['additional_delay'] = merged['delay_minutes_to'] - merged['delay_minutes_from']

                # Store statistics of the delays
                delay_stats[pair] = {
                    'mean_delay': merged['additional_delay'].mean(),
                    'median_delay': merged['additional_delay'].median(),
                    'std_dev': merged['additional_delay'].std(),
                    'count': len(merged)
                }

        self.delay_stats = delay_stats
        print(f"Delay statistics calculated for {route}:")  # Debu
        for pair, stats in delay_stats.items():
            print(f"{pair[0]}->{pair[1]}: mean={stats['mean_delay']:.1f} min, median={stats['median_delay']:.1f} min")  # Debug



    def load_station_data(self, csv_path: str):
        #Load station data from CSV file with robust error handling
        self.stations = []  # List of station names
        self.station_codes = {}  # Dictionary mapping names to codes

        try:
            # Try reading CSV with different possible delimiters
            try:
                df = pd.read_csv(csv_path)
            except:
                # Try with different encodings if first attempt fails
                try:
                    df = pd.read_csv(csv_path, encoding='latin1')
                except:
                    df = pd.read_csv(csv_path, encoding='utf-16')

            print(f"Successfully loaded CSV with {len(df)} rows")  # Debug

            # Process each row
            for _, row in df.iterrows():
                try:
                    # Get station name - try different possible column names
                    station_name = None
                    for col in ['name', 'station_name', 'location', 'Station_Name']:
                        if col in row:
                            station_name = str(row[col]).strip()
                            if station_name and station_name != '\\N':
                                break

                    if not station_name:
                        continue

                    # Get station code - try different possible column names
                    tiploc = None
                    for col in ['alpha3', 'tiploc', 'station_code', 'code']:
                        if col in row:
                            tiploc = str(row[col]).strip()
                            if tiploc and tiploc != '\\N':
                                break

                    if not tiploc:
                        continue

                    # Add to stations list if not already present
                    if station_name not in self.stations:
                        self.stations.append(station_name)

                    # Add primary mapping
                    self.station_codes[station_name.lower()] = tiploc

                    # Handle aliases if available
                    if 'alias' in row:
                        alias = str(row['alias']).strip()
                        if alias and alias != '\\N':
                            self.station_codes[alias.lower()] = tiploc

                    # Handle alternative name columns
                    if 'alternative_name' in row:
                        alt_name = str(row['alternative_name']).strip()
                        if alt_name and alt_name != '\\N':
                            self.station_codes[alt_name.lower()] = tiploc

                except Exception as e:
                    print(f"Error processing row {_}: {e}")  # Debug/logging output
                    continue

            print(f"Loaded {len(self.stations)} stations total")  # Debug/logging output
            print(f"Sample stations: {self.stations[:5]}")  # Debug/logging output

        except Exception as e:
            print(f"Error loading station CSV: {e}")  # Debug/logging output


# create sql tables


    def create_tables(self):
        #Create database tables for conversation logging
        cursor = self.db_conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_input TEXT,
                bot_response TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.db_conn.commit()



    def log_conversation(self, user_input: str, response: str):
        #Log conversation to database
        cursor = self.db_conn.cursor()
        cursor.execute('''
            INSERT INTO conversations (user_input, bot_response)
            VALUES (?, ?)
        ''', (user_input, response))
        self.db_conn.commit()






    def initialize_nlp_matchers(self):
        if not nlp:
            print("spaCy not available, skipping NLP matcher initialization.")  # Debug/logging output
            return
        self.matcher = Matcher(nlp.vocab)
        self.matcher.add("DEPARTURE", [[{"LOWER": {"IN": ["from", "departing"]}}, {"ENT_TYPE": "GPE"}]])
        self.matcher.add("DESTINATION", [[{"LOWER": {"IN": ["to", "going"]}}, {"ENT_TYPE": "GPE"}]])


    def match_station(self, text: str, route: Optional[str] = None) -> Optional[str]:
        #Improved station matching with route context
        text = text.lower().strip()

        # Handle common abbreviations
        abbrev_map = {
            'london': ['liverpool street', 'lst'],
            'norwich': ['nrwi', 'nrwh']
        }

        # Prioritize stations on the specified route
        if route and route in self.station_sequences:
            for code in self.station_sequences[route]:
                name = self.get_station_name(code).lower()
                if text == name or text in name:
                    return self.get_station_name(code)  # Return result
                for station, abbrevs in abbrev_map.items():
                    if station in name and any(abbr in text for abbr in abbrevs):
                        return self.get_station_name(code)  # Return result

        # Check full names
        for name in self.station_codes.keys():
            if text == name.lower():
                return name  # Return result
            for station, abbrevs in abbrev_map.items():
                if station in name.lower() and any(abbr in text for abbr in abbrevs):
                    return name  # Return result

        # Fuzzy matching as fallback
        best_match = None
        best_score = 0
        for name in self.station_codes.keys():
            score = fuzz.partial_ratio(text, name.lower())
            if score > best_score and score > 80:
                best_score = score
                best_match = name

        return best_match  # Return result





    def get_station_code(self, station_name: str) -> Optional[str]:
        #Get station code from station name
        return self.station_codes.get(station_name.lower())  # Return result



    def get_station_name(self, code: str) -> str:
        #Get proper station name from code
        for name, station_code in self.station_codes.items():
            if station_code == code:
                # Clean up names with parentheses
                if '(' in name:
                    return name.split('(')[0].strip()  # Return result
                return name  # Return result
        return code  # Fallback to code if name not found  # Return result


    def generate_station_suggestions(self, partial_name: str, route: str = None) -> List[str]:
        #Generate station suggestions based on input
        partial = partial_name.lower()
        matches = []

        # If we have a route, prioritize stations on that route
        if route and route in self.station_sequences:
            station_codes = self.station_sequences[route]
            for code in station_codes:
                name = self.get_station_name(code)
                if name and partial in name.lower():
                    matches.append(name)

        # Also check all stations
        for name in self.station_codes.keys():
            if partial in name.lower() and name not in matches:
                matches.append(name)

        return sorted(matches, key=lambda x: len(x))[:5]  # Return top 5 shortest matches  # Return result





    def parse_relative_date(self, date_str: str) -> Optional[str]:
 
        today = datetime.now().date()
        date_str = date_str.lower().strip()

        if date_str in ['today', 'now']:
            return today.strftime('%d/%m/%Y')  # Return result
        elif date_str == 'tomorrow':
            return (today + timedelta(days=1)).strftime('%d/%m/%Y')  # Return result
        elif date_str == 'day after tomorrow':
            return (today + timedelta(days=2)).strftime('%d/%m/%Y')  # Return result
        elif date_str.startswith('next '):
            if date_str.endswith('week'):
                return (today + timedelta(weeks=1)).strftime('%d/%m/%Y')  # Return result
            elif date_str.endswith('month'):
                return (today.replace(month=today.month + 1)).strftime('%d/%m/%Y')  # Return result
            day_name = date_str[5:].capitalize()
            weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                        'Friday', 'Saturday', 'Sunday']
            if day_name in weekdays:
                days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                if days_ahead == 0:  # Today is that day
                    days_ahead = 7  # Next week
                return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')  # Return result
        elif date_str.startswith('in '):
            parts = date_str.split()
            if len(parts) >= 3 and parts[1].isdigit():
                num = int(parts[1])
                if parts[2] in ['day', 'days']:
                    return (today + timedelta(days=num)).strftime('%d/%m/%Y')  # Return result
                elif parts[2] in ['week', 'weeks']:
                    return (today + timedelta(weeks=num)).strftime('%d/%m/%Y')  # Return result
        elif date_str.startswith('on '):
            day_name = date_str[3:].capitalize()
            weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                        'Friday', 'Saturday', 'Sunday']
            if day_name in weekdays:
                days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                if days_ahead == 0:  # Today is that day
                    days_ahead = 7  # Next week
                return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')  # Return result

        # Try standard date formats
        try:
            datetime.strptime(date_str, '%d/%m/%Y')
            return date_str  # Return result
        except ValueError:
            pass

        return None  # Return result





    def parse_time(self, time_str: str) -> Optional[str]:
#parse time in HH:mm format
        try:
            dt = parse(time_str, fuzzy=True)
            return dt.strftime('%H:%M')  # Return result
        except:
            return None  # Return result



    def extract_booking_info(self, text: str) -> Tuple[Dict, List]:
        print(f"\nExtracting info from: '{text}'")  # Debug/logging output
        extracted = {}
        missing = []
        lower = text.lower().strip()

        # Detect route for station matching
        route = self.detect_route(text)

        # Process station matching
        if self.current_state == self.STATES['PARSE_BOOKING'] or 'from' in lower or 'to' in lower:
            from_match = re.search(
                r'(?:from|departing)\s+([a-z\s]+?)\s+'
                r'(?:to|going to|arriving in|arriving at)\s+([a-z\s]+?)(?:\s|$)',
                text, re.IGNORECASE
            )
            if from_match:
                from_station = self.match_station(from_match.group(1), route)
                to_station = self.match_station(from_match.group(2), route)
                print(f"Matched stations: from={from_station}, to={to_station}")  # Debug/logging output
                if from_station and to_station:
                    extracted['origin'] = self.station_codes.get(from_station.lower())
                    extracted['destination'] = self.station_codes.get(to_station.lower())

        # --- PASSENGER EXTRACTION ---
        adults_match = re.search(r'(\d+)\s*(?:adult|adults)', lower)
        children_match = re.search(r'(\d+)\s*(?:child|children)', lower)
        passengers_match = re.search(r'(\d+)\s*(?:passenger|passengers)', lower)

        if adults_match:
            extracted['adults'] = int(adults_match.group(1))

        if children_match:
            extracted['children'] = int(children_match.group(1))

        # Fallback for generic passenger nuimbers

        if not adults_match and passengers_match:
            extracted['adults'] = int(passengers_match.group(1))
            extracted['children'] = 0

        print(f"Extracted passengers: adults={extracted.get('adults', 'not set')}, children={extracted.get('children', 'not set')}")  # Debug/logging output


        # --- TIME EXTRACTION ---
        if re.search(r'\b(before|arrive by)\b', lower):
            extracted['depart_type'] = 'arriving'
            extracted['time_preference'] = 'by'
        else:
            extracted['depart_type'] = 'departing'
            extracted['time_preference'] = 'at'

        # Extract the actual time
        time_match = re.search(
            r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)', lower
        )
        if time_match:
            hour = int(time_match.group(1))
            minute = int(time_match.group(2) or '00')
            period = time_match.group(3).lower()

            # Convert to 24-hour format
            if period == 'pm' and hour != 12:
                hour += 12
            elif period == 'am' and hour == 12:
                hour = 0

            requested_time = datetime.now().replace(hour=hour, minute=minute, second=0, microsecond=0)

            # Adjust time backward by 60 mins if user says 'before' or 'arrive by'
            if extracted.get('time_preference') == 'by':
                requested_time -= timedelta(minutes=60)

            if self.expecting_return_time:
                extracted['return_time'] = requested_time.strftime('%H:%M')
                print(f"Extracted return time: '{extracted['return_time']}' (adjusted for 'before')")  # Debug/logging output
                self.expecting_return_time = False
            else:
                extracted['time'] = requested_time.strftime('%H:%M')
                print(f"Extracted time: '{extracted['time']}' (adjusted for 'before')")  # Debug/logging output

        # --- DATE EXTRACTION ---
        date_pattern = (
            r'\b(?:'
            r'today|tomorrow|day after tomorrow|'
            r'next\s+\w+|'
            r'in\s+\d+\s*(?:day|days|week|weeks)|'
            r'\d+\s*(?:day|days|week|weeks)\s*(?:later|after)|'
            r'(?:on\s+|the\s+|on\s+the\s+)?\d{1,2}(?:st|nd|rd|th)?\s*(?:of\s*)?[A-Za-z]+(?:\s*\d{4})?(?!\s*(?:am|pm))|'  # Day-first
            r'(?:on\s+|the\s+)?[A-Za-z]+\s*\d{1,2}(?:st|nd|rd|th)?(?:\s*\d{4})?(?!\s*(?:am|pm))|'  # Month-first
            r'on\s+\d{1,2}(?:st|nd|rd|th)?\s*(?:of\s*)?[A-Za-z]+(?:\s*\d{4})?(?!\s*(?:am|pm))'  # "on 15th of July"
            r')\b'
        )
        matches = re.findall(date_pattern, lower, re.IGNORECASE)
        print(f"Date pattern matches: {matches}")  # Debu

        for phrase in matches:
            original_phrase = phrase
            phrase = re.sub(r'\b(on|the|of)\b', ' ', phrase, flags=re.IGNORECASE).strip()
            phrase = re.sub(r'(\d+)(h)\b', r'\1th', phrase, flags=re.IGNORECASE)
            phrase = ' '.join(phrase.split())
            print(f"Trying to parse date phrase: '{phrase}' (original: '{original_phrase}')")  # Debug  
            relative_base = self.booking_details.get('date') if self.booking_details.get('is_return') else None
            parsed = self.parse_date(phrase, relative_base=relative_base)
            if parsed:
                print(f"Parsed date: '{parsed}' from phrase: '{phrase}'")  # Debug  
                if self.booking_details.get('is_return'):
                    extracted['return_date'] = parsed
                else:
                    extracted['date'] = parsed
                break

        # Fallback: fuzzy parsing
        if not extracted.get('date') and not extracted.get('return_date'):
            date_indicators = [
                'today', 'tomorrow', 'next', 'in ', 'on ',
                'jan', 'feb', 'mar', 'apr', 'may', 'jun',
                'jul', 'aug', 'sep', 'oct', 'nov', 'dec',
                r'\d{1,2}/\d{1,2}/\d{2,4}',
                r'\d{1,2}(?:st|nd|rd|th|h)',
                r'[A-Za-z]+\s*\d{1,2}',
                r'\d{1,2}\s*[A-Za-z]+'
            ]
            if any(re.search(ind, lower, re.IGNORECASE) for ind in date_indicators) and not time_match:
                parse_text = text.lower().split(' on ', 1)[1].strip() if ' on ' in lower else text
                try:
                    dt = parse(parse_text, fuzzy=True, dayfirst=True)
                    out = dt.strftime('%d/%m/%Y')
                    print(f"Fuzzy parsed date: '{out}' from text: '{parse_text}'")  # Debug 
                    if self.booking_details.get('is_return'):
                        extracted['return_date'] = out
                    else:
                        extracted['date'] = out
                except Exception as e:
                    print(f"Fuzzy parsing exception: {str(e)} for text: '{parse_text}'")  # Debug


        # --- CHECK REQUIRED FIELDS & MISSING ---
        required = ['origin', 'destination', 'date', 'time']
        if self.booking_details.get('is_return'):
            required.extend(['return_date', 'return_time'])

        missing = [
            field for field in required
            if not (extracted.get(field) or self.booking_details.get(field))
        ]

        print(f"Extracted: {extracted}")  # Debug
        print(f"Missing: {missing}")  # Debug
        return extracted, missing  # Return result


    def build_url(self):
   
        origin = self.booking_details['origin']
        destination = self.booking_details['destination']
        date_str = self.booking_details['date']
        time_str = self.booking_details['time']
        adults = self.booking_details['adults']
        children = self.booking_details['children']
        return_date_str = self.booking_details['return_date']
        return_time_str = self.booking_details['return_time']
        depart_type = self.booking_details['depart_type']
        time_preference = self.booking_details['time_preference']

        day, month, year = date_str.split("/")
        hour, minute = time_str.split(":")
        minute = self.round_down_to_quarter(minute)
        leaving_date = f"{day}{month}{year[2:]}"
        leaving_hour = hour.zfill(2)

        params = {
            "origin": origin,
            "destination": destination,
            "leavingType": depart_type,
            "leavingDate": leaving_date,
            "leavingHour": leaving_hour,
            "leavingMin": minute,
            "adults": adults,
            "children": children,
            "extraTime": "0"
        }

        if time_preference == 'by':
            params['leavingType'] = 'arriving'
        elif time_preference == 'after':
            params['leavingType'] = 'departing'

        if return_date_str and return_time_str:
            return_day, return_month, return_year = return_date_str.split("/")
            return_hour, return_minute = return_time_str.split(":")
            return_minute = self.round_down_to_quarter(return_minute)
            params.update({
                "returningType": depart_type,
                "returningDate": f"{return_day}{return_month}{return_year[2:]}",
                "returningHour": return_hour.zfill(2),
                "returningMin": return_minute
            })

        url = "https://www.nationalrail.co.uk/journey-planner/?" + urlencode(params)
        return url, int(hour), int(minute)  # Return result






    def is_station_on_route(self, station_code: str, route: str) -> bool:

        return station_code in self.station_sequences.get(route, [])  # Return result


    def validate_station_on_route(self, station_name: str, route: str) -> Tuple[bool, str]:

        matched_station = self.match_station(station_name)
        if not matched_station:
            return False, "Station not recognized"  # Return result

        station_code = self.station_codes.get(matched_station.lower())
        if not station_code:
            return False, "Station code not found"  # Return result

        # Special case for London Liverpool Street
        if 'london' in matched_station.lower() and 'LST' in self.station_sequences.get(route, []):
            return True, 'LST'  # Return result

        if station_code not in self.station_sequences.get(route, []):
            route_stations = [self.get_station_name(code) for code in self.station_sequences[route]]
            return False, f"This station isn't on your {route} route. Please choose from: {', '.join(route_stations)}"  # Return result

        return True, station_code  # Return result



    def generate_missing_prompt(self, missing: List[str]) -> str:
 
        prompt = "Could you please provide the "
        missing_items = []
        for field in missing:
            if field == 'origin':
                missing_items.append('departure station')
            elif field == 'destination':
                missing_items.append('destination station')
            elif field == 'date':
                missing_items.append('travel date')
            elif field == 'time':
                missing_items.append('travel time')
            elif field == 'return_date':
                missing_items.append('return date')
            elif field == 'return_time':
                missing_items.append('return time')
        if len(missing_items) == 1:
            prompt += missing_items[0]
        elif len(missing_items) == 2:
            prompt += f"{missing_items[0]} and {missing_items[1]}"
        else:
            prompt += ", ".join(missing_items[:-1]) + f", and {missing_items[-1]}"
        return prompt + "?"  # Return result




    def validate_date(self, date_str: str) -> bool:
        #Validate date format DD/MM/YYYY or relative date expressions

        # First try relative date parsing
        relative_date = self.parse_relative_date(date_str)
        if relative_date:
            return True  # Return result

        # Then try standard date format
        try:
            day, month, year = date_str.split('/')
            if len(day) == 2 and len(month) == 2 and len(year) == 4:
                datetime.strptime(date_str, '%d/%m/%Y')
                return True  # Return result
        except ValueError:
            return False  # Return result
        return False  # Return result




    def validate_time(self, time_str: str) -> bool:
        
        try:
            datetime.strptime(time_str, '%H:%M')
            return True  # Return result
        except ValueError:  
            return False  # Return result



    def detect_route(self, text):
        text = text.lower()
        if "norwich" in text and "london" in text:
            if text.find("norwich") < text.find("london"):
                return 'Norwich-LST'  # Return result
            return 'LST-Norwich'  # Return result
        return None  # Return result





    def validate_direction(self, route: str, current: str, destination: str) -> bool:

        try:
            stations = self.station_sequences[route]
            return stations.index(current) < stations.index(destination)  # Return result
        except (ValueError, KeyError):
            return False  # Return result




    def detect_intent(self, text: str) -> str:
        processed = self.preprocess_text(text)
        if not processed:
            return "unknown"

        tokens = set(processed)

        # General question triggers (e.g., bike policy, refunds)
        qa_triggers = {
    'bike', 'luggage', 'refund', 'miss', 'ticket', 'arrive', 'children', 'travel',
    'platform', 'toilet', 'compensation', 'repay', 'wifi', 'drink', 'seat',
    'pets', 'animal', 'quiet', 'coach', 'charging', 'socket', 'lost', 'property',
    'railcard', 'discount', 'access', 'step-free', 'payment', 'contactless',
    'engineering', 'works', 'tracker', 'delay', 'cancel', 'reservation',
    'schedule', 'timetable', 'early', 'late', 'bag', 'machine'
}

        if tokens & qa_triggers:
            return "general_question"

        # Delay inquiry triggers
        delay_triggers = {
            'delay', 'late', 'arriv', 'time', 'status',
            'long', 'when', 'current', 'predict', 'hold',
            'behind', 'schedule', 'timetable', 'due'
        }
        if tokens & delay_triggers:
            # Check for route mentions to classify as complex inquiry
            if 'norwich' in tokens and 'london' in tokens:
                return "complex_delay_inquiry"
            return "delay_inquiry"

        # Greeting detection
        greeting_words = {'hello', 'hi', 'hey', 'greet'}
        if tokens & greeting_words:
            return "greeting"

        # Farewell detection
        farewell_words = {'bye', 'goodbye', 'exit', 'quit', 'farewell'}
        if tokens & farewell_words:
            return "farewell"

        # Booking detection
        booking_triggers = {
            'book', 'ticket', 'journey', 'travel', 'train',
            'schedul', 'timet', 'from', 'to', 'depart', 'arriv',
            'go', 'need', 'want', 'would'
        }
        if tokens & booking_triggers:
            return "booking"

        return "unknown"






    def handle_general_question(self, user_input):
        # Load QnA KB
        with open("qna_kb.json", "r") as f:
            kb = json.load(f)

        best_match = None
        best_score = 0

        for entry in kb:
            score = fuzz.token_sort_ratio(user_input.lower(), entry['question'].lower())
            if score > best_score and score > 75:
                best_score = score
                best_match = entry

        if best_match:
            answer = best_match['answer']
        else:


            # Try reasoning fallback
            self.general_engine = GeneralRuleEngine()
            self.general_engine.reset()
            if "refund" in user_input and "miss" in user_input:
                self.general_engine.declare(Fact(topic="refund", condition="missed_train"))
            elif "bike" in user_input:
                self.general_engine.declare(Fact(topic="bike"))
            self.general_engine.run()
            answer = getattr(self.general_engine, 'response', None)
            if not answer:
                answer = "Sorry, I don't have an answer for that yet."

        # After answering, return to options
        self.current_state = self.STATES['GET_OPTION']
        return f"{answer}\n\n{self.options_prompt}"
    
    ##gets best anaswer from teh faqs
        
    def get_best_answer(user_question, qa_kb):
        best_match = None
        best_score = 0
        for qa in qa_kb:
            score = fuzz.token_sort_ratio(user_question.lower(), qa["question"].lower())
            if score > best_score:
                best_score = score
                best_match = qa
        return best_match["answer"] if best_score > 75 else "Sorry, I don't have an answer for that."

    def extract_delay_info(self, text: str) -> dict:

        extracted = {}
        text_lower = text.lower()

        # Check for route
        if 'norwich' in text_lower and 'london' in text_lower:
            if text_lower.find('norwich') < text_lower.find('london'):
                extracted['route'] = 'Norwich-LST'
            else:
                extracted['route'] = 'LST-Norwich'

        # Check for delay duration
        delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)s?', text_lower)
        if delay_match:
            extracted['delay'] = int(delay_match.group(1))
            # Convert hours to minutes if needed
            if delay_match.group(2) in ['hour', 'hr']:
                extracted['delay'] *= 60

        # Check for station mentions
        for word in text_lower.split():
            matched_station = self.match_station(word)
            if matched_station:
                # First station mentioned is likely current station
                if 'current_station' not in extracted:
                    extracted['current_station'] = matched_station
                # Second station mentioned is likely destination
                elif 'destination' not in extracted:
                    extracted['destination'] = matched_station

        return extracted  # Return result



    def make_delay_prediction(self) -> str:
        #generate prediction when all details are available
        try:
            route = self.delay_details['route']
            current = self.delay_details['current_station']
            dest = self.delay_details['destination']
            delay = self.delay_details['reported_delay']

            if not self.validate_direction(route, current, dest):
                return ("You appear to be traveling in the wrong direction for this route. "  # Return result
                        f"From {self.get_station_name(current)}, you should be heading towards: "
                        f"{', '.join(self.get_station_name(code) for code in self.station_sequences[route][self.station_sequences[route].index(current) + 1:])}")

            rf_prediction = self.delay_predictor.predict(route, current)
            rf_prediction = max(0, rf_prediction) # Removes negative predictions
            total_delay = delay + rf_prediction

            # Reuse normal travel time logic
            arrival_info = self.predict_arrival(route, current, total_delay, dest)

            self.current_state = self.STATES['GET_OPTION']
            return (  # Return result
                f" Based on current data, the predicted delay from {self.get_station_name(current)} is approximately {rf_prediction:.1f} minutes.\n"
                f" Including your reported delay of {delay} minutes, total delay is estimated at {total_delay:.1f} minutes.\n\n"
                f"{arrival_info}\n\n"
                f"{self.options_prompt}"
            )

        except Exception as e:
            return f"Sorry, I couldn't make a prediction: {str(e)}"  # Return result



    def handle_destination_input(self, user_input: str) -> str:
        is_valid, message = self.validate_station_on_route(
            user_input,
            self.delay_details['route']
        )

        if not is_valid:
            # Generate suggestions from route stations
            route_stations = self.station_sequences.get(self.delay_details['route'], [])
            suggestions = [
                self.get_station_name(code)
                for code in route_stations
                if user_input.lower() in self.get_station_name(code).lower()
            ]

            if suggestions:
                return f"{message}\nDid you mean: {', '.join(suggestions[:3])}"  # Return result
            return message  # Return result

        self.delay_details['destination'] = message  # message contains station_code here
        return self.make_delay_prediction()  # Return result




    def handle_delay_inquiry(self, user_input: str) -> str:

        # Extract route
        if 'norwich' in user_input.lower() and 'london' in user_input.lower():
            if user_input.lower().find('norwich') < user_input.lower().find('london'):
                route = 'Norwich-LST'
            else:
                route = 'LST-Norwich'
        else:
            return "Please specify your route as 'Norwich to London' or 'London to Norwich'"  # Return result

        # Extract delay minutes
        delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)', user_input.lower())
        delay = int(delay_match.group(1)) if delay_match else None

        # Update context
        self.delay_details = {'route': route}
        if delay:
            self.delay_details['reported_delay'] = delay

        # Determine next question
        if not self.delay_details.get('current_station'):
            self.current_state = self.STATES['GET_CURRENT_STATION']
            return "Which station are you currently at?"  # Return result
        elif not self.delay_details.get('reported_delay'):
            self.current_state = self.STATES['GET_DELAY_DURATION']
            return "How many minutes delayed is your train?"  # Return result
        elif not self.delay_details.get('destination'):
            self.current_state = self.STATES['GET_DESTINATION']
            return "Which station is your destination?"  # Return result
        else:
            return self.make_delay_prediction()  # Return result


    def handle_delay_duration(self, user_input: str) -> str:


        try:
            # Extract delay in minutes from input
            delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)?', user_input.lower())
            if delay_match:
                delay = int(delay_match.group(1))
                if delay_match.group(2) in ['hour', 'hr']:
                    delay *= 60  # Convert hours to minutes
                self.delay_details['reported_delay'] = delay

                # Ask for destination if not already known
                if not self.delay_details.get('destination'):
                    self.current_state = self.STATES['GET_DESTINATION']
                    return "Which station is your destination?"  # Return result
                else:
                    return self.make_delay_prediction()  # Return result
            else:
                return "Please enter the delay time in minutes or hours (e.g. '15 minutes', '1 hour')."  # Return result
        except Exception as e:
            return f"Sorry, I couldn't understand the delay duration. Error: {str(e)}"  # Return result





    def generate_response(self, user_input: str) -> str:
        # Log the raw input
        self.log_conversation(user_input, "")

        # Emptyinput guard
        if not user_input.strip():
            if self.current_state == self.STATES['GET_MISSING_INFO']:
                return "Please provide the missing information: " + self.generate_missing_prompt(self.missing_fields)  # Return result
            return "Please provide a valid input."  # Return result

        # Add this new condition here - handles "ok" after ticket display
        if user_input.lower() == 'ok' and self.current_state == self.STATES['GET_OPTION']:
            return self.options_prompt  # Return result

        # Then continue with the existing intent detection

        if user_input.lower() in ['go back', 'main menu', 'start over', 'menu']:
            self.booking_details = {k: None for k in self.booking_details}  # Optional: clear context
            self.current_state = self.STATES['GET_OPTION']
            return "Returning to the main menu...\n\n" + self.options_prompt

        intent = self.detect_intent(user_input)

        # Handle general Q&A anytime
        # Only handle general questions in neutral states (not booking/delay flow)
        if intent == "general_question" and self.current_state in [
            self.STATES['GET_OPTION'],
            self.STATES['GREETING'],
            self.STATES['FAREWELL']
        ]:
            answer = self.handle_general_question(user_input)
            self.current_state = self.STATES['GET_OPTION']
            return answer




        # Farewell at any time
        if intent == "farewell":
            self.current_state = self.STATES['FAREWELL']
            return random.choice(self.farewells)  # Return result

        # GREETING -> OPTIONS
        if self.current_state == self.STATES['GREETING']:
            if intent == "delay_inquiry":
                self.current_state = self.STATES['DELAY_INQUIRY']
                return "I can help with delay predictions. First, which route are you on? (Norwich to London or London to Norwich)"  # Return result
            else:
                self.current_state = self.STATES['GET_OPTION']
                return f"{random.choice(self.greetings)}\n{self.options_prompt}"  # Return result
            



        # GET_OPTION -> either DELAY or BOOKING flow
        elif self.current_state == self.STATES['GET_OPTION']:
            if intent == "delay_inquiry" or "2" in user_input:
                self.current_state = self.STATES['DELAY_INQUIRY']
                return "I can help with delay predictions. First, which route are you on? (Norwich to London or London to Norwich)"  # Return result
            elif intent == "booking" or "1" in user_input:
                self.current_state = self.STATES['PARSE_BOOKING']
                return "Please tell me about your journey. For example: 'I want to travel from Norwich to London tomorrow at 3pm'"  # Return result
            elif "3" in user_input or intent == "farewell":
                self.current_state = self.STATES['FAREWELL']
                return random.choice(self.farewells)  # Return result
            else:
                return "I didn't understand that. Please choose:\n1. Book tickets\n2. Check for delays\n3. Ask any other questions\n4. Exit"  # Return result

        # DELAY INQUIRY STATES
        elif self.current_state == self.STATES['DELAY_INQUIRY']:
            return self.handle_delay_inquiry(user_input)  # Return result
        elif self.current_state == self.STATES['GET_CURRENT_STATION']:
            return self.handle_current_station(user_input)  # Return result
        elif self.current_state == self.STATES['GET_DELAY_DURATION']:
            return self.handle_delay_duration(user_input)  # Return result
        elif self.current_state == self.STATES['GET_DESTINATION']:
            return self.handle_destination_input(user_input)  # Return result

        # PARSE_BOOKING -> extract details
        elif self.current_state == self.STATES['PARSE_BOOKING']:
            extracted, missing = self.extract_booking_info(user_input)
            if extracted:
                self.booking_details.update(extracted)
                self.missing_fields = missing
                if not missing:
                    # all core fields gathered; now ask about return
                    self.current_state = self.STATES['ASK_RETURN']
                    return self.process_booking()  # shows summary + "Would you like a return ticket?"  # Return result
                else:
                    # still missing something
                    self.current_state = self.STATES['GET_MISSING_INFO']
                    response = "I understood:"
                    if 'origin' in extracted:
                        response += f"\n- From: {self.get_station_name(extracted['origin'])}"
                    if 'destination' in extracted:
                        response += f"\n- To: {self.get_station_name(extracted['destination'])}"
                    if 'date' in extracted:
                        response += f"\n- Date: {extracted['date']}"
                    if 'time' in extracted:
                        response += f"\n- Time: {extracted['time']}"
                    response += "\n\n" + self.generate_missing_prompt(missing)
                    return response  # Return result
            return ("I couldn't understand your booking request. "  # Return result
                    "Please try something like: 'I want to travel from Norwich to London tomorrow at 3pm'")

        elif self.current_state == self.STATES['GET_MISSING_INFO']:
            extracted, missing = self.extract_booking_info(user_input)
            if extracted:
                for k, v in extracted.items():
                    if v:
                        self.booking_details[k] = v
                self.missing_fields = missing
                if not missing:
                    # Instead of confirming immediately, transition to ASK_RETURN if not already handling return
                    if not self.booking_details.get('is_return') and 'return_date' not in self.missing_fields:
                        self.current_state = self.STATES['ASK_RETURN']
                        return self.process_booking()  # Shows summary + asks about return ticket  # Return result
                    else:
                        # If handling return, confirm booking
                        self.booking_details['confirmed'] = True
                        return self.process_booking(confirm=True)  # Return result
                else:
                    response = "I understood:"
                    if self.booking_details.get('origin'):
                        response += f"\n- From: {self.get_station_name(self.booking_details['origin'])}"
                    if self.booking_details.get('destination'):
                        response += f"\n- To: {self.get_station_name(self.booking_details['destination'])}"
                    if self.booking_details.get('date'):
                        response += f"\n- Date: {self.booking_details['date']}"
                    if self.booking_details.get('time'):
                        response += f"\n- Time: {self.booking_details['time']}"
                    response += "\n\n" + self.generate_missing_prompt(missing)
                    return response  # Return result
            return "Please provide the missing information: " + self.generate_missing_prompt(self.missing_fields)  # Return result

        # ASK_RETURN  single handler only
        elif self.current_state == self.STATES['ASK_RETURN']:
            user_input_lower = user_input.lower().strip()
            if user_input_lower in ['yes', 'y']:
                self.booking_details['is_return'] = True
                self.expecting_return_time = True  # <-- set the flag here
                self.current_state = self.STATES['GET_MISSING_INFO']
                self.missing_fields = ['return_date', 'return_time']
                return "Sureplease provide your return date and time (e.g. 'June 6th at 4pm')"  # Return result
            elif user_input_lower in ['no', 'n']:
                self.booking_details['is_return'] = False
                # Explicitly clear return fields
                self.booking_details['return_date'] = None
                self.booking_details['return_time'] = None
                self.booking_details['return_depart_type'] = None
                self.booking_details['return_time_preference'] = None
                self.booking_details['confirmed'] = True
                return self.process_booking(confirm=True)  # Return result
            else:
                return "Please answer 'yes' or 'no' to whether you want a return ticket."  # Return result

        # FAREWELL state
        elif self.current_state == self.STATES['FAREWELL']:
            if user_input.lower() in ['menu', 'options', 'back']:
                self.current_state = self.STATES['GET_OPTION']
                return self.options_prompt  # Return result
            return random.choice(self.farewells)  # Return result
        

        # Catch-all
        return "Sorry, I didn't understand that."  # Return result



    def handle_current_station(self, user_input: str) -> str:


        is_valid, message = self.validate_station_on_route(
            user_input,
            self.delay_details['route']
        )

        if not is_valid:
            # Try generating suggestions
            suggestions = self.generate_station_suggestions(user_input, self.delay_details['route'])
            if suggestions:
                return f"{message}\nDid you mean: {', '.join(suggestions[:3])}?"  # Return result
            return message  # Return result

        self.delay_details['current_station'] = message  # This is the valid station code

        # Ask for next piece of info
        if not self.delay_details.get('reported_delay'):
            self.current_state = self.STATES['GET_DELAY_DURATION']
            return "How many minutes delayed is your train?"  # Return result
        elif not self.delay_details.get('destination'):
            self.current_state = self.STATES['GET_DESTINATION']
            return "Which station is your destination?"  # Return result
        else:
            return self.make_delay_prediction()  # Return result




    def process_booking(self, confirm=False):
        # Ensure date is set if missing
        if not self.booking_details.get('date'):
            self.booking_details['date'] = (datetime.now() + timedelta(days=1)).strftime('%d/%m/%Y')

        summary = "Here's your journey summary:\n"
        summary += f"From: {self.get_station_name(self.booking_details['origin'])}\n"
        summary += f"To: {self.get_station_name(self.booking_details['destination'])}\n"
        summary += f"Date: {self.booking_details['date']}\n"
        time_label = "Arrive by" if self.booking_details['time_preference'] == 'by' else "Depart after"
        summary += f"{time_label}: {self.booking_details['time']}\n"
        summary += f"Adults: {self.booking_details['adults']}\n"
        summary += f"Children: {self.booking_details['children']}\n"

        if self.booking_details.get('return_date') and self.booking_details.get('return_time'):
            summary += f"Return Date: {self.booking_details['return_date']}\n"
            summary += f"Return Time: {self.booking_details['return_time']}\n"

        if confirm:
            try:
                result = compare_ticket_prices(
                    origin=self.booking_details['origin'],
                    destination=self.booking_details['destination'],
                    depart_date=self.booking_details['date'],
                    depart_time=self.booking_details['time'],
                    depart_type=self.booking_details['depart_type'],
                    time_preference=self.booking_details['time_preference'],
                    is_return=self.booking_details.get('is_return', False),
                    return_date=self.booking_details['return_date'],
                    return_time=self.booking_details['return_time'],
                    return_type=self.booking_details['depart_type'],
                    adults=self.booking_details['adults'],
                    children=self.booking_details['children']
                )

                summary += "\n\nTicket Comparison:\n"
                if result['national_rail']['total_price'] is not None:
                    summary += f" National Rail: {result['national_rail']['total_price']:.2f}  {result['national_rail']['url']}\n"
                else:
                    summary += "National Rail: No result found.\n"

                if result['thameslink']['total_price'] is not None:
                    summary += f"Thameslink: {result['thameslink']['total_price']:.2f}  {result['thameslink']['url']}\n"
                else:
                    summary += "Thameslink: No result found.\n"

                summary += f"\nVerdict: {result['verdict']}"



#modift the transtioitions of states
                self.current_state = self.STATES['GET_OPTION']
                return summary + f"\n\n{self.options_prompt}"  # Return result

            except Exception as e:
                return f" Error during ticket search: {str(e)}"  # Return result

        if not self.booking_details.get('is_return'):
            self.current_state = self.STATES['ASK_RETURN']
            return summary + "\nWould you like to book a return ticket? (yes/no)"  # Return result

        return summary + "\nPlease provide your return date and time (e.g. 'June 6th at 4pm')"  # Return result



    def calculate_normal_travel_times(self, route):


        if route not in self.delay_data or not isinstance(self.delay_data[route], pd.DataFrame):
            return None  # Return result

        df = self.delay_data[route].copy()
        normal_times = {}

        # First try to automatically detect time columns
        time_cols = {'arrival': None, 'departure': None}

        # Common column name patterns to check
        arrival_patterns = ['arrival', 'pta', 'planned_arrival']
        departure_patterns = ['departure', 'ptd', 'planned_departure']

        # Try to find matching columns
        for col in df.columns:
            col_lower = col.lower()
            if not time_cols['arrival'] and any(pattern in col_lower for pattern in arrival_patterns):
                time_cols['arrival'] = col
            if not time_cols['departure'] and any(pattern in col_lower for pattern in departure_patterns):
                time_cols['departure'] = col

        # If we couldn't find columns, use hardcoded defaults based on route
        if not time_cols['arrival'] or not time_cols['departure']:
            if route == 'Norwich-LST':
                time_cols = {
                    'arrival': 'planned_arrival_time',
                    'departure': 'planned_departure_time'
                }
            else:  # LST-Norwich
                time_cols = {
                    'arrival': 'gbtt_pta',
                    'departure': 'gbtt_ptd'
                }

        # Check if the required columns exist
        missing_cols = [col for col in time_cols.values() if col not in df.columns]
        if missing_cols:
            print(f"Warning: Could not find time columns in {route} data. Tried: {time_cols}")  # Debug/logging output
            print(f"Actual columns: {df.columns.tolist()}")  # Debug/logging output
            return None  # Return result

        # Convert time columns to datetime.time objects
        for col in time_cols.values():
            # First convert to string if needed
            df[col] = df[col].astype(str)
            # Then parse times, handling empty/missing values
            df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time

        stations = self.station_sequences[route]

        for i in range(len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]

            # Get all services between these stations
            from_df = df[df['location'] == from_stn]
            to_df = df[df['location'] == to_stn]

            # Merge on rid and date_of_service to match the same train
            merged = pd.merge(
                from_df[['rid', 'date_of_service', time_cols['departure']]].rename(
                    columns={time_cols['departure']: 'departure_time'}),
                to_df[['rid', 'date_of_service', time_cols['arrival']]].rename(
                    columns={time_cols['arrival']: 'arrival_time'}),
                on=['rid', 'date_of_service'],
                suffixes=('_from', '_to')
            )

            if not merged.empty:
#calclute travel times


                def calculate_time(row):
                    try:
                        dep_time = row['departure_time']
                        arr_time = row['arrival_time']

                        if pd.isna(dep_time) or pd.isna(arr_time):
                            return np.nan  # Return result

                        # Create datetime objects for calculation
                        dep_dt = datetime.combine(datetime.today(), dep_time)
                        arr_dt = datetime.combine(datetime.today(), arr_time)

                        # Handle overnight trains (negative time difference)
                        if arr_dt < dep_dt:
                            arr_dt += timedelta(days=1)

                        return (arr_dt - dep_dt).total_seconds() / 60  # Return result
                    except Exception as e:
                        print(f"Error calculating time: {e}")  # Debug/logging output
                        return np.nan  # Return result

                merged['travel_time'] = merged.apply(calculate_time, axis=1)

                # Drop rows with invalid times
                merged = merged.dropna(subset=['travel_time'])

                if not merged.empty:
                    # Store median travel time
                    normal_times[(from_stn, to_stn)] = merged['travel_time'].median()
                    print(f"Normal time {from_stn}->{to_stn}: {normal_times[(from_stn, to_stn)]:.1f} minutes")  # Debug/logging output
                else:
                    print(f"No valid time data for {from_stn}->{to_stn}")  # Debug/logging output
                    normal_times[(from_stn, to_stn)] = 30  # Default fallback
            else:
                print(f"No matching services for {from_stn}->{to_stn}")  # Debug/logging output
                normal_times[(from_stn, to_stn)] = 30  # Default fallback

        return normal_times  # Return result




    def predict_arrival(self, route, current_station, delay, destination):


        normal_times = self.normal_travel_times.get(route, {})
        stations = self.station_sequences.get(route, [])

        if not normal_times:
            print(f"Warning: No normal travel times available for route {route}")  # Debug/logging output
            # Create default normal times
            normal_times = {(stations[i], stations[i + 1]): 30
                            for i in range(len(stations) - 1)}

        if current_station not in stations or destination not in stations:
            print(f"Warning: Stations not in route {route}")  # Debug/logging output
            return None  # Return result

        current_idx = stations.index(current_station)
        dest_idx = stations.index(destination)

        # Calculate normal travel time
        normal_travel_time = 0
        for i in range(current_idx, dest_idx):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)
            normal_travel_time += normal_times.get(pair, 30)  # Default to 30 minutes if no data

        # Add the reported delay
        total_time = normal_travel_time + delay

        # Get current time
        now = datetime.now()

        # Calculate estimated arrival time
        estimated_arrival = now + timedelta(minutes=total_time)

        # Format the output
        output = (
            f"Normally this journey takes {normal_travel_time:.1f} minutes.\n"
            f"With your {delay} minute delay, the total expected travel time is {total_time:.1f} minutes.\n"
            f"Estimated arrival time: {estimated_arrival.strftime('%H:%M')}"
        )

        return output  # Return result




    def calculate_schedule_times(self, route, stations):


        if route not in self.delay_data or not isinstance(self.delay_data[route], pd.DataFrame):
            return None  # Return result

        df = self.delay_data[route]
        schedule_times = [0]  # Start at 0 minutes for first station

        for i in range(1, len(stations)):
            from_stn = stations[i - 1]
            to_stn = stations[i]

            # Get typical travel time between these stations
            mask = (df['location'] == from_stn)
            departures = df[mask]['actual_departure'].dropna()

            mask = (df['location'] == to_stn)
            arrivals = df[mask]['actual_arrival'].dropna()

            if not departures.empty and not arrivals.empty:
                # Convert times to minutes since midnight for calculation
                departures_min = departures.apply(lambda x: x.hour * 60 + x.minute)
                arrivals_min = arrivals.apply(lambda x: x.hour * 60 + x.minute)

                # Calculate median travel time in minutes
                typical_time = (arrivals_min.median() - departures_min.median())

                # Handle overnight trains (negative time difference)
                if typical_time < 0:
                    typical_time += 1440  # Add 24 hours in minutes

                schedule_times.append(schedule_times[-1] + typical_time)
            else:
                # Fallback: use 30 minutes between stations if no data
                schedule_times.append(schedule_times[-1] + 30)

        return schedule_times  # Return result

if __name__ == "__main__":
    print("Initializing Train Ticket Chatbot...")  # Debug/logging output
    chatbot = TrainTicketChatbotWithBooking()
    print("\nLoading and analyzing delay data...")  # Debug/logging output
    chatbot.load_delay_data()
    print("\nWelcome to TrainBot! Type 'exit' to quit at any time.")  # Debug/logging output
    while True:
        user_input = input("\nYou: ").strip()
        if user_input.lower() in ['exit', 'quit', 'bye', 'goodbye']:
            print("TrainBot:", random.choice(chatbot.farewells))  # Debug/logging output
            break
        response = chatbot.generate_response(user_input)
        print("TrainBot:", response)  # Debug/logging output
