import re 
import collections
import collections.abc 
from ChatBotTrainMixed import compare_ticket_prices 
collections.Mapping = collections.abc.Mapping
collections.Sequence = collections.abc.Sequence
collections.Iterable = collections.abc.Iterable
from experta import KnowledgeEngine, Rule, Fact, MATCH  
from fuzzywuzzy import fuzz 
import sqlite3  
import random 
import pandas as pd 
import nltk 
from nltk.stem import PorterStemmer, WordNetLemmatizer  
from nltk.corpus import stopwords 
from typing import Dict, List, Optional, Tuple 
import spacy 
from spacy.matcher import Matcher  
from selenium import webdriver  
from selenium.webdriver.common.by import By  
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC  
from urllib.parse import urlencode 
from datetime import datetime, timedelta 
import time 
from dateutil.parser import parse 
from sklearn.ensemble import RandomForestRegressor  
from sklearn.model_selection import train_test_split 
from sklearn.metrics import mean_absolute_error  
import numpy as np
import json


with open("qna_kb.json") as f:
    qa_kb = json.load(f)

#NLP installized
try:
    nlp = spacy.load('en_core_web_sm')
    print("NLP model loaded successfully.")  
except:
    print("spaCy not available. Some features will be limited.")  
    nlp = None



#RandomForestDelayPredictor
class RandomForestDelayPredictor:


    def __init__(self, station_sequences):
        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42
        )
        self.station_sequences = station_sequences
        self.station_to_idx = self._create_station_mapping()
        self.is_trained = False
        self.feature_names = ['day_of_week', 'hour_of_day', 'station_idx', 'route_type']


    # This cetat stationmapping 
    def _create_station_mapping(self):
        station_map = {}
        for route, stations in self.station_sequences.items():
            for idx, station in enumerate(stations):
                station_map[(route, station)] = idx
        return station_map 


    # pRPROCEINSG data 
    def preprocess_data(self, df):
        """Prepare data with dynamic station handling"""
        df = df.copy()

        #Time to datebate 
        if 'planned_departure' in df.columns and not pd.api.types.is_datetime64_any_dtype(df['planned_departure']):
            try:
                df['planned_departure'] = pd.to_datetime(df['planned_departure'], errors='coerce')
            except:
                pass

        #Cacuate delays here 
        if 'delay_minutes' not in df.columns and 'planned_departure' in df.columns and 'actual_departure' in df.columns:
            df['delay_minutes'] = (
                    (df['actual_departure'] - df['planned_departure']).dt.total_seconds() / 60
            )

        #STation added to position
        df['station_idx'] = df.apply(
            lambda x: self.station_to_idx.get((x['route'], x['location']), -1),
            axis=1
        )

        #Feature engineering
        df['day_of_week'] = df['planned_departure'].dt.dayofweek
        df['hour_of_day'] = df['planned_departure'].dt.hour
        df['route_type'] = df['route'].map({
            'Norwich-LST': 0,
            'LST-Norwich': 1
        })
        df = df.dropna(subset=['delay_minutes', 'station_idx'])

        return df  # Return result


    #Data trainigs
    def train(self, df):
        processed = self.preprocess_data(df)
        X = processed[self.feature_names]
        y = processed['delay_minutes']
        X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)
        self.model.fit(X_train, y_train)
        self.is_trained = True
        preds = self.model.predict(X_val)
        mae = mean_absolute_error(y_val, preds)
        print(f"Model trained on {len(X_train)} samples. Validation MAE: {mae:.2f} minutes")  # Debug/logging output


    #Preditcion delays 
    def predict(self, route, current_station):
        """Make prediction using current conditions"""
        if not self.is_trained:
            raise ValueError("Model not trained yet")

        station_idx = self.station_to_idx.get((route, current_station), -1)
        if station_idx == -1:
            return None 
        #Deature are standraadiez
        input_features = pd.DataFrame([{
            'day_of_week': datetime.now().weekday(),
            'hour_of_day': datetime.now().hour,
            'station_idx': station_idx,
            'route_type': 0 if route == 'Norwich-LST' else 1
        }])[self.feature_names]  

        return float(self.model.predict(input_features)[0])  

#Rule based reasong engnee
class DelayReasoningEngine(KnowledgeEngine):
    """Rule-based system for delay predictions"""

    def __init__(self, station_sequences, delay_stats):
        super().__init__()
        self.station_sequences = station_sequences
        self.delay_stats = delay_stats

    @Rule(Fact(route=MATCH.r),
          Fact(current_station=MATCH.s),
          Fact(reported_delay=MATCH.d))

    #Delay predictions
    def predict_delay(self, r, s, d):
        stations = self.station_sequences[r]
        current_idx = stations.index(s)
        total_delay = float(d)
        for i in range(current_idx, len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)
            if pair in self.delay_stats:
                total_delay += self.delay_stats[pair]['median_delay']

        self.declare(Fact(predicted_delay=total_delay))

#Here main chatvots 
class GeneralRuleEngine(KnowledgeEngine):
    @Rule(Fact(topic="refund"), Fact(condition="missed_train"))
    def handle_missed_train_refund(self):
        self.declare(Fact(response="If you missed your train, check if your ticket is flexible or refundable."))

    @Rule(Fact(topic="bike"))
    def handle_bike_policy(self):
        self.declare(Fact(response="Folding bikes are allowed anytime. Standard bikes are allowed off-peak."))


class TrainTicketChatbotWithBooking:
    #Installizataions here 
    def __init__(self):
        self.stemmer = PorterStemmer()
        self.lemmatizer = WordNetLemmatizer()
        self.stop_words = set(nltk.corpus.stopwords.words('english'))
        self.greetings = [
            "Hello! I'm TrainBot, how can I help with your train journey today?",
            "Hi there! How can I assist with your train travel?"
        ]
        self.farewells = ["Thank you for using our service. Safe travels!"]
        self.options_prompt = "What would you like to do today? You can:\n1. Book tickets\n2. Check for delays\n3. Ask any other questions\n4. Exit"
        self.STATES = {
            'GREETING': 0,
            'GET_OPTION': 1,
            'PARSE_BOOKING': 2,
            'GET_MISSING_INFO': 3,
            'CONFIRM_BOOKING': 4,
            'FAREWELL': 5,
            'DELAY_INQUIRY': 6,
            'GET_CURRENT_STATION': 7,
            'GET_DELAY_DURATION': 8,
            'GET_DESTINATION': 9,
            'ASK_RETURN': 10
        }
        self.current_state = self.STATES['GREETING']
        self.booking_details = {
            'origin': None,
            'destination': None,
            'date': None,
            'time': None,
            'adults': '1',
            'children': '0',
            'confirmed': False,
            'is_return': False
        }
        self.missing_fields = []
        self.stations = []
        self.station_codes = {}
        self.load_station_data('stations.csv')
        self.db_conn = sqlite3.connect(':memory:', check_same_thread=False)
        self.create_tables()
        self.load_delay_data()
        self.delay_engine = DelayReasoningEngine(
            station_sequences=self.station_sequences,
            delay_stats=self.delay_stats
        )
        self.delay_predictor = RandomForestDelayPredictor(
            station_sequences=self.station_sequences
        )
        self._train_delay_model()
        self.delay_details = {}
        self.normal_travel_times = {}
        for route in self.station_sequences:
            self.normal_travel_times[route] = self.calculate_normal_travel_times(route)

    #Fore delay predcition
    def load_delay_data(self):
        """Load and process delay data from CSV files"""
        self.delay_data = {
            'Norwich-LST': [],
            'LST-Norwich': []
        }

        #Data from norwich to london data 
        for year in [2022, 2023, 2024]:
            try:
                df = pd.read_csv(f'{year}_service_details_Norwich_to_London.csv')
                df['route'] = 'Norwich-LST'
                self.delay_data['Norwich-LST'].append(df)
            except FileNotFoundError:
                print(f"Warning: {year}_service_details_Norwich_to_London.csv not found")  

        #Data from london to norwich data
        for year in [2022, 2023, 2024]:
            try:
                df = pd.read_csv(f'{year}_service_details_London_to_Norwich.csv')
                df['route'] = 'LST-Norwich'
                self.delay_data['LST-Norwich'].append(df)
            except FileNotFoundError:
                print(f"Warning: {year}_service_details_London_to_Norwich.csv not found")  

        #ALL route are cobined 
        for route in self.delay_data:
            if self.delay_data[route]:
                self.delay_data[route] = pd.concat(self.delay_data[route])
                print(f"Loaded {len(self.delay_data[route])} records for {route} route")  

        self.extract_station_sequences()
        self.preprocess_delay_data()
        self.expecting_return_time = False


    #Station sequenced extracted 
    def extract_station_sequences(self):
        """Properly extract station sequences from CSV files"""
        self.station_sequences = {'Norwich-LST': [], 'LST-Norwich': []}

        if isinstance(self.delay_data['Norwich-LST'], pd.DataFrame):
            df = self.delay_data['Norwich-LST']
            sequences = df.groupby('rid').apply(
                lambda x: x.sort_values('planned_departure_time')['location'].unique().tolist()
            )
            if len(sequences) > 0:
                self.station_sequences['Norwich-LST'] = sequences.iloc[0]  # Take first sequence
        if isinstance(self.delay_data['LST-Norwich'], pd.DataFrame):
            df = self.delay_data['LST-Norwich']
            sequences = df.groupby('rid').apply(
                lambda x: x.sort_values('gbtt_ptd')['location'].unique().tolist()
            )
            if len(sequences) > 0:
                self.station_sequences['LST-Norwich'] = sequences.iloc[0] 

        print(f"Final station sequences: {self.station_sequences}") 


    # Preporcessing the text 
    def preprocess_text(self, text: str) -> List[str]:
        try:
            tokens = nltk.word_tokenize(text.lower())
            tokens = [token for token in tokens
                      if token not in self.stop_words and token.isalpha()]

            processed_tokens = []
            for token in tokens:
                try:
                    lemma = self.lemmatizer.lemmatize(token)
                    stem = self.stemmer.stem(lemma)
                    if len(stem) < len(lemma) - 1:
                        processed_tokens.append(stem)
                    else:
                        processed_tokens.append(lemma)
                except:
                    processed_tokens.append(token)
            return processed_tokens 
        except Exception as e:
            print(f"Error preprocessing text: {e}")  
            return []  


    #Parasing data
    def parse_date(self, date_str: str, relative_base: Optional[str] = None) -> Optional[str]:
        try:
            date_str = date_str.lower().strip()
            date_str = re.sub(r'\b(on|the|of)\b', ' ', date_str, flags=re.IGNORECASE)
            date_str = re.sub(r'(\d+)(h)\b', r'\1th', date_str, flags=re.IGNORECASE)
            date_str = ' '.join(date_str.split())

            today = datetime.now().date()
            #Handel the expressions
            if date_str in ['today']:
                return today.strftime('%d/%m/%Y')
            elif date_str == 'tomorrow':
                return (today + timedelta(days=1)).strftime('%d/%m/%Y')
            elif date_str == 'day after tomorrow':
                return (today + timedelta(days=2)).strftime('%d/%m/%Y')
            elif date_str == 'next week':
                return (today + timedelta(weeks=1)).strftime('%d/%m/%Y')
            elif date_str == 'next month':
                next_month = today.replace(day=1) + timedelta(days=32)
                return next_month.replace(day=min(today.day, 28)).strftime('%d/%m/%Y')
            elif re.match(r'in\s+(\d+)\s*weeks?', date_str):
                num = int(re.findall(r'\d+', date_str)[0])
                return (today + timedelta(weeks=num)).strftime('%d/%m/%Y')
            elif re.match(r'in\s+(\d+)\s*days?', date_str):
                num = int(re.findall(r'\d+', date_str)[0])
                return (today + timedelta(days=num)).strftime('%d/%m/%Y')
            # Hnadels the weekdays 
            if date_str.startswith("next "):
                weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                day_name = date_str[5:]
                if day_name in weekdays:
                    days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                    if days_ahead == 0:
                        days_ahead = 7
                    return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')

            #Handels 3 days and other phrases 
            match = re.search(r'(\d+)\s*(day|days|week|weeks)\s*(later|after)', date_str)
            if match:
                num = int(match.group(1))
                unit = match.group(2)
                base_date = datetime.strptime(relative_base, '%d/%m/%Y') if relative_base else today
                if 'week' in unit:
                    return (base_date + timedelta(weeks=num)).strftime('%d/%m/%Y')
                else:
                    return (base_date + timedelta(days=num)).strftime('%d/%m/%Y')

            #try natural languages 
            patterns = [
                r'(\d{1,2})(?:st|nd|rd|th)?\s*([A-Za-z]+)(?:\s*(\d{4}))?',  
                r'([A-Za-z]+)\s*(\d{1,2})(?:st|nd|rd|th)?(?:\s*(\d{4}))?'   
            ]
            for pattern in patterns:
                match = re.search(pattern, date_str)
                if match:
                    if pattern.startswith(r'(\d{1,2})'):
                        day, month, year = match.groups()
                    else:
                        month, day, year = match.groups()

                    month_map = {
                        'january': '01', 'jan': '01',
                        'february': '02', 'feb': '02',
                        'march': '03', 'mar': '03',
                        'april': '04', 'apr': '04',
                        'may': '05',
                        'june': '06', 'jun': '06',
                        'july': '07', 'jul': '07',
                        'august': '08', 'aug': '08',
                        'september': '09', 'sep': '09',
                        'october': '10', 'oct': '10',
                        'november': '11', 'nov': '11',
                        'december': '12', 'dec': '12'
                    }
                    month_num = month_map.get(month.lower())
                    if not month_num:
                        continue
                    year = year or str(today.year)
                    return f"{day.zfill(2)}/{month_num}/{year}"
            try:
                dt = parse(date_str, fuzzy=True, dayfirst=True)
                return dt.strftime('%d/%m/%Y')
            except Exception:
                return None

        except Exception as e:
            print(f"[ERROR] parse_date failed: {str(e)}")
            return None

    #Delaty of teh train model 
    def _train_delay_model(self):
        """Train model with all available data"""
        try:
            combined_data = pd.concat([
                self.delay_data['Norwich-LST'],
                self.delay_data['LST-Norwich']
            ], ignore_index=True)

            print("\nColumns available for training:", combined_data.columns.tolist()) 
            if len(combined_data) < 100:
                raise ValueError(f"Not enough training data (only {len(combined_data)} samples)")

            self.delay_predictor.train(combined_data)
            print("Random Forest model trained successfully") 

        except Exception as e:
            print(f"\nError training Random Forest model: {str(e)}")  
            print("Will use rule-based predictions only") 
            self.delay_predictor.is_trained = False


    #Preprocessing the train delays 
    def preprocess_delay_data(self):
        """Clean and prepare delay data for analysis"""
        for route in self.delay_data:
            if isinstance(self.delay_data[route], pd.DataFrame):
                df = self.delay_data[route].copy()
                time_cols = ['planned_arrival', 'planned_departure', 'actual_arrival', 'actual_departure']
                for col in time_cols:
                    if col in df:
                        df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time
            #Standradized 
            if route == 'Norwich-LST':
                column_map = {
                    'planned_arrival_time': 'planned_arrival',
                    'planned_departure_time': 'planned_departure',
                    'actual_arrival_time': 'actual_arrival',
                    'actual_departure_time': 'actual_departure'
                }
                df = df.rename(columns={k: v for k, v in column_map.items() if k in df.columns})
                if 'late_canc_reason.1' in df.columns:
                    df = df.drop(columns=['late_canc_reason.1'])

            elif route == 'LST-Norwich':
                column_map = {
                    'gbtt_pta': 'planned_arrival',
                    'gbtt_ptd': 'planned_departure',
                    'actual_ta': 'actual_arrival',
                    'actual_td': 'actual_departure'
                }
                df = df.rename(columns={k: v for k, v in column_map.items() if k in df.columns})
            required_cols = ['planned_departure', 'actual_departure', 'location']
            missing_cols = [col for col in required_cols if col not in df.columns]
            if missing_cols:
                print(f"Warning: Missing columns in {route} data: {missing_cols}") 
                continue
            #Time to datetime 
            time_cols = ['planned_arrival', 'planned_departure', 'actual_arrival', 'actual_departure']
            for col in time_cols:
                if col in df:
                    df[col] = df[col].replace('', pd.NA)
                    try:
                        df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time
                    except:
                        try:
                            df[col] = pd.to_datetime(df[col], format='%H:%M:%S', errors='coerce').dt.time
                        except:
                            df[col] = pd.NA

            #Delays minutes 
            df['delay_minutes'] = 0
            mask = df['actual_departure'].notna() & df['planned_departure'].notna()
            df.loc[mask, 'delay_minutes'] = df[mask].apply(
                lambda x: (datetime.combine(datetime.today(), x['actual_departure']) -
                           datetime.combine(datetime.today(), x['planned_departure'])).total_seconds() / 60,
                axis=1
            )
            #Filter data minutes 
            df = df[df['delay_minutes'].abs() <= 120]
            self.delay_data[route] = df
            self.calculate_typical_delays(route, df)


    #Typical dealay claculatecd 
    def calculate_typical_delays(self, route, df):
        """Calculate typical delays between stations for a route"""
        if route not in self.station_sequences:
            return

        stations = self.station_sequences[route]
        delay_stats = {}

        for i in range(len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)

            #Get all station in this 
            from_df = df[df['location'] == from_stn]
            to_df = df[df['location'] == to_stn]
            merged = pd.merge(
                from_df[['rid', 'date_of_service', 'actual_departure', 'delay_minutes']],
                to_df[['rid', 'date_of_service', 'actual_arrival', 'delay_minutes']],
                on=['rid', 'date_of_service'],
                suffixes=('_from', '_to')
            )

            if not merged.empty:
                merged['additional_delay'] = merged['delay_minutes_to'] - merged['delay_minutes_from']
                delay_stats[pair] = {
                    'mean_delay': merged['additional_delay'].mean(),
                    'median_delay': merged['additional_delay'].median(),
                    'std_dev': merged['additional_delay'].std(),
                    'count': len(merged)
                }

        self.delay_stats = delay_stats
        print(f"Delay statistics calculated for {route}:")  
        for pair, stats in delay_stats.items():
            print(f"{pair[0]}->{pair[1]}: mean={stats['mean_delay']:.1f} min, median={stats['median_delay']:.1f} min") 


    #Load station data
    def load_station_data(self, csv_path: str):
        """Load station data from CSV file with robust error handling"""
        self.stations = []  #List of station names
        self.station_codes = {}  #Dictionary mapping names to codes

        try:
            try:
                df = pd.read_csv(csv_path)
            except:
                try:
                    df = pd.read_csv(csv_path, encoding='latin1')
                except:
                    df = pd.read_csv(csv_path, encoding='utf-16')

            print(f"Successfully loaded CSV with {len(df)} rows")  
            #Process each row
            for _, row in df.iterrows():
                try:
                    #Get the stationname here
                    station_name = None
                    for col in ['name', 'station_name', 'location', 'Station_Name']:
                        if col in row:
                            station_name = str(row[col]).strip()
                            if station_name and station_name != '\\N':
                                break

                    if not station_name:
                        continue
                    #STation code 
                    tiploc = None
                    for col in ['alpha3', 'tiploc', 'station_code', 'code']:
                        if col in row:
                            tiploc = str(row[col]).strip()
                            if tiploc and tiploc != '\\N':
                                break

                    if not tiploc:
                        continue

                    #Add station if not present
                    if station_name not in self.stations:
                        self.stations.append(station_name)

                    #Add primary mapping
                    self.station_codes[station_name.lower()] = tiploc

                    #Handle aliases if available
                    if 'alias' in row:
                        alias = str(row['alias']).strip()
                        if alias and alias != '\\N':
                            self.station_codes[alias.lower()] = tiploc

                    #Handle alternative name columns
                    if 'alternative_name' in row:
                        alt_name = str(row['alternative_name']).strip()
                        if alt_name and alt_name != '\\N':
                            self.station_codes[alt_name.lower()] = tiploc

                except Exception as e:
                    print(f"Error processing row {_}: {e}") 
                    continue

            print(f"Loaded {len(self.stations)} stations total")  
            print(f"Sample stations: {self.stations[:5]}") 

        except Exception as e:
            print(f"Error loading station CSV: {e}") 


    #Tables created 
    def create_tables(self):
        """Create database tables for conversation logging"""
        cursor = self.db_conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS conversations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_input TEXT,
                bot_response TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.db_conn.commit()
    #Log converstations
    def log_conversation(self, user_input: str, response: str):
        """Log conversation to database"""
        cursor = self.db_conn.cursor()
        cursor.execute('''
            INSERT INTO conversations (user_input, bot_response)
            VALUES (?, ?)
        ''', (user_input, response))
        self.db_conn.commit()
    #Nlp instalized
    def initialize_nlp_matchers(self):
        if not nlp:
            print("spaCy not available, skipping NLP matcher initialization.")  # Debug/logging output
            return
        self.matcher = Matcher(nlp.vocab)
        self.matcher.add("DEPARTURE", [[{"LOWER": {"IN": ["from", "departing"]}}, {"ENT_TYPE": "GPE"}]])
        self.matcher.add("DESTINATION", [[{"LOWER": {"IN": ["to", "going"]}}, {"ENT_TYPE": "GPE"}]])
    #Match stations
    def match_station(self, text: str, route: Optional[str] = None) -> Optional[str]:
        """Improved station matching with route context"""
        text = text.lower().strip()
        abbrev_map = {
            'london': ['liverpool street', 'lst'],
            'norwich': ['nrwi', 'nrwh']
        }
        #Special route priotized 
        if route and route in self.station_sequences:
            for code in self.station_sequences[route]:
                name = self.get_station_name(code).lower()
                if text == name or text in name:
                    return self.get_station_name(code)  
                for station, abbrevs in abbrev_map.items():
                    if station in name and any(abbr in text for abbr in abbrevs):
                        return self.get_station_name(code)  
        for name in self.station_codes.keys():
            if text == name.lower():
                return name 
            for station, abbrevs in abbrev_map.items():
                if station in name.lower() and any(abbr in text for abbr in abbrevs):
                    return name  

        #Fuzzy match 
        best_match = None
        best_score = 0
        for name in self.station_codes.keys():
            score = fuzz.partial_ratio(text, name.lower())
            if score > best_score and score > 80:
                best_score = score
                best_match = name
        return best_match  

    #Get station code 
    def get_station_code(self, station_name: str) -> Optional[str]:
        """Get station code from station name"""
        return self.station_codes.get(station_name.lower()) 


    #Get station name 
    def get_station_name(self, code: str) -> str:
        """Get proper station name from code"""
        for name, station_code in self.station_codes.items():
            if station_code == code:
                if '(' in name:
                    return name.split('(')[0].strip()  
                return name 
        return code  


    #Generate statio suggestion
    def generate_station_suggestions(self, partial_name: str, route: str = None) -> List[str]:
        """Generate station suggestions based on input"""
        partial = partial_name.lower()
        matches = []

        #Prioritize stations on that route
        if route and route in self.station_sequences:
            station_codes = self.station_sequences[route]
            for code in station_codes:
                name = self.get_station_name(code)
                if name and partial in name.lower():
                    matches.append(name)

        for name in self.station_codes.keys():
            if partial in name.lower() and name not in matches:
                matches.append(name)

        return sorted(matches, key=lambda x: len(x))[:5]  


    #Prase relative data 
    def parse_relative_date(self, date_str: str) -> Optional[str]:
        """Improved relative date parsing"""
        today = datetime.now().date()
        date_str = date_str.lower().strip()

        if date_str in ['today', 'now']:
            return today.strftime('%d/%m/%Y')  
        elif date_str == 'tomorrow':
            return (today + timedelta(days=1)).strftime('%d/%m/%Y')  
        elif date_str == 'day after tomorrow':
            return (today + timedelta(days=2)).strftime('%d/%m/%Y')  
        elif date_str.startswith('next '):
            if date_str.endswith('week'):
                return (today + timedelta(weeks=1)).strftime('%d/%m/%Y')  
            elif date_str.endswith('month'):
                return (today.replace(month=today.month + 1)).strftime('%d/%m/%Y')  
            day_name = date_str[5:].capitalize()
            weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                        'Friday', 'Saturday', 'Sunday']
            if day_name in weekdays:
                days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                if days_ahead == 0:  
                    days_ahead = 7  #Next week
                return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')  
        elif date_str.startswith('in '):
            parts = date_str.split()
            if len(parts) >= 3 and parts[1].isdigit():
                num = int(parts[1])
                if parts[2] in ['day', 'days']:
                    return (today + timedelta(days=num)).strftime('%d/%m/%Y')  
                elif parts[2] in ['week', 'weeks']:
                    return (today + timedelta(weeks=num)).strftime('%d/%m/%Y')  
        elif date_str.startswith('on '):
            day_name = date_str[3:].capitalize()
            weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
                        'Friday', 'Saturday', 'Sunday']
            if day_name in weekdays:
                days_ahead = (weekdays.index(day_name) - today.weekday()) % 7
                if days_ahead == 0:  #Today is that day
                    days_ahead = 7  #Next week
                return (today + timedelta(days=days_ahead)).strftime('%d/%m/%Y')  

        #Date formated
        try:
            datetime.strptime(date_str, '%d/%m/%Y')
            return date_str 
        except ValueError:
            pass

        return None 


    #Time parse
    def parse_time(self, time_str: str) -> Optional[str]:
        """Parse time string to HH:MM format"""
        try:
            dt = parse(time_str, fuzzy=True)
            return dt.strftime('%H:%M') 
        except:
            return None  


    #Extract booking information
    def extract_booking_info(self, text: str) -> Tuple[Dict, List]:
        print(f"\nExtracting info from: '{text}'")  
        extracted = {}
        missing = []
        lower = text.lower().strip()

        #Detect route for station matching
        route = self.detect_route(text)

        #Process station matching
        if self.current_state == self.STATES['PARSE_BOOKING'] or 'from' in lower or 'to' in lower:
            from_match = re.search(
                r'(?:from|departing)\s+([a-z\s]+?)\s+'
                r'(?:to|going to|arriving in|arriving at)\s+([a-z\s]+?)(?:\s|$)',
                text, re.IGNORECASE
            )
            if from_match:
                from_station = self.match_station(from_match.group(1), route)
                to_station = self.match_station(from_match.group(2), route)
                print(f"Matched stations: from={from_station}, to={to_station}")  
                if from_station and to_station:
                    extracted['origin'] = self.station_codes.get(from_station.lower())
                    extracted['destination'] = self.station_codes.get(to_station.lower())

        #Extraction pasenger
        adults_match = re.search(r'(\d+)\s*(?:adult|adults)', lower)
        children_match = re.search(r'(\d+)\s*(?:child|children)', lower)
        passengers_match = re.search(r'(\d+)\s*(?:passenger|passengers)', lower)

        if adults_match:
            extracted['adults'] = int(adults_match.group(1))

        if children_match:
            extracted['children'] = int(children_match.group(1))

        #Fallback fro generic 
        if not adults_match and passengers_match:
            extracted['adults'] = int(passengers_match.group(1))
            extracted['children'] = 0

        print(f"Extracted passengers: adults={extracted.get('adults', 'not set')}, children={extracted.get('children', 'not set')}")  # Debug/logging output


        #Time extracted 
        if re.search(r'\b(before|arrive by)\b', lower):
            extracted['depart_type'] = 'arriving'
            extracted['time_preference'] = 'by'
        else:
            extracted['depart_type'] = 'departing'
            extracted['time_preference'] = 'at'
        time_match = re.search(
            r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)', lower
        )
        if time_match:
            hour = int(time_match.group(1))
            minute = int(time_match.group(2) or '00')
            period = time_match.group(3).lower()

            #Convert 24 hour 
            if period == 'pm' and hour != 12:
                hour += 12
            elif period == 'am' and hour == 12:
                hour = 0

            requested_time = datetime.now().replace(hour=hour, minute=minute, second=0, microsecond=0)

            #Before and after 
            if extracted.get('time_preference') == 'by':
                requested_time -= timedelta(minutes=60)

            if self.expecting_return_time:
                extracted['return_time'] = requested_time.strftime('%H:%M')
                print(f"Extracted return time: '{extracted['return_time']}' (adjusted for 'before')") 
                self.expecting_return_time = False
            else:
                extracted['time'] = requested_time.strftime('%H:%M')
                print(f"Extracted time: '{extracted['time']}' (adjusted for 'before')") 
        #Data extraction
        date_pattern = (
            r'\b(?:'
            r'today|tomorrow|day after tomorrow|'
            r'next\s+\w+|'
            r'in\s+\d+\s*(?:day|days|week|weeks)|'
            r'\d+\s*(?:day|days|week|weeks)\s*(?:later|after)|'
            r'(?:on\s+|the\s+|on\s+the\s+)?\d{1,2}(?:st|nd|rd|th)?\s*(?:of\s*)?[A-Za-z]+(?:\s*\d{4})?(?!\s*(?:am|pm))|'  #Dayfirst
            r'(?:on\s+|the\s+)?[A-Za-z]+\s*\d{1,2}(?:st|nd|rd|th)?(?:\s*\d{4})?(?!\s*(?:am|pm))|'  #Month first 
            r'on\s+\d{1,2}(?:st|nd|rd|th)?\s*(?:of\s*)?[A-Za-z]+(?:\s*\d{4})?(?!\s*(?:am|pm))'  #on 15th of July
            r')\b'
        )
        matches = re.findall(date_pattern, lower, re.IGNORECASE)
        print(f"Date pattern matches: {matches}") 

        for phrase in matches:
            original_phrase = phrase
            phrase = re.sub(r'\b(on|the|of)\b', ' ', phrase, flags=re.IGNORECASE).strip()
            phrase = re.sub(r'(\d+)(h)\b', r'\1th', phrase, flags=re.IGNORECASE)
            phrase = ' '.join(phrase.split())
            print(f"Trying to parse date phrase: '{phrase}' (original: '{original_phrase}')")  
            relative_base = self.booking_details.get('date') if self.booking_details.get('is_return') else None
            parsed = self.parse_date(phrase, relative_base=relative_base)
            if parsed:
                print(f"Parsed date: '{parsed}' from phrase: '{phrase}'")  
                if self.booking_details.get('is_return'):
                    extracted['return_date'] = parsed
                else:
                    extracted['date'] = parsed
                break

        #Fuzzy parsing
        if not extracted.get('date') and not extracted.get('return_date'):
            date_indicators = [
                'today', 'tomorrow', 'next', 'in ', 'on ',
                'jan', 'feb', 'mar', 'apr', 'may', 'jun',
                'jul', 'aug', 'sep', 'oct', 'nov', 'dec',
                r'\d{1,2}/\d{1,2}/\d{2,4}',
                r'\d{1,2}(?:st|nd|rd|th|h)',
                r'[A-Za-z]+\s*\d{1,2}',
                r'\d{1,2}\s*[A-Za-z]+'
            ]
            if any(re.search(ind, lower, re.IGNORECASE) for ind in date_indicators) and not time_match:
                parse_text = text.lower().split(' on ', 1)[1].strip() if ' on ' in lower else text
                try:
                    dt = parse(parse_text, fuzzy=True, dayfirst=True)
                    out = dt.strftime('%d/%m/%Y')
                    print(f"Fuzzy parsed date: '{out}' from text: '{parse_text}'")  
                    if self.booking_details.get('is_return'):
                        extracted['return_date'] = out
                    else:
                        extracted['date'] = out
                except Exception as e:
                    print(f"Fuzzy parsing exception: {str(e)} for text: '{parse_text}'")  

        #requird firled missing 
        required = ['origin', 'destination', 'date', 'time']
        if self.booking_details.get('is_return'):
            required.extend(['return_date', 'return_time'])

        missing = [
            field for field in required
            if not (extracted.get(field) or self.booking_details.get(field))
        ]

        print(f"Extracted: {extracted}")  
        print(f"Missing: {missing}") 
        return extracted, missing  


    #Url build
    def build_url(self):
        """Build the booking URL from collected details"""
        origin = self.booking_details['origin']
        destination = self.booking_details['destination']
        date_str = self.booking_details['date']
        time_str = self.booking_details['time']
        adults = self.booking_details['adults']
        children = self.booking_details['children']
        return_date_str = self.booking_details['return_date']
        return_time_str = self.booking_details['return_time']
        depart_type = self.booking_details['depart_type']
        time_preference = self.booking_details['time_preference']

        day, month, year = date_str.split("/")
        hour, minute = time_str.split(":")
        minute = self.round_down_to_quarter(minute)
        leaving_date = f"{day}{month}{year[2:]}"
        leaving_hour = hour.zfill(2)

        params = {
            "origin": origin,
            "destination": destination,
            "leavingType": depart_type,
            "leavingDate": leaving_date,
            "leavingHour": leaving_hour,
            "leavingMin": minute,
            "adults": adults,
            "children": children,
            "extraTime": "0"
        }

        if time_preference == 'by':
            params['leavingType'] = 'arriving'
        elif time_preference == 'after':
            params['leavingType'] = 'departing'

        if return_date_str and return_time_str:
            return_day, return_month, return_year = return_date_str.split("/")
            return_hour, return_minute = return_time_str.split(":")
            return_minute = self.round_down_to_quarter(return_minute)
            params.update({
                "returningType": depart_type,
                "returningDate": f"{return_day}{return_month}{return_year[2:]}",
                "returningHour": return_hour.zfill(2),
                "returningMin": return_minute
            })

        url = "https://www.nationalrail.co.uk/journey-planner/?" + urlencode(params)
        return url, int(hour), int(minute)  





    #Station in route
    def is_station_on_route(self, station_code: str, route: str) -> bool:
        """Check if station exists in route sequence"""
        return station_code in self.station_sequences.get(route, []) 


    #Validate staion in route 
    def validate_station_on_route(self, station_name: str, route: str) -> Tuple[bool, str]:
        """Check if station exists and is on the specified route"""
        matched_station = self.match_station(station_name)
        if not matched_station:
            return False, "Station not recognized"  

        station_code = self.station_codes.get(matched_station.lower())
        if not station_code:
            return False, "Station code not found" 

        #Special case for London Liverpool Street
        if 'london' in matched_station.lower() and 'LST' in self.station_sequences.get(route, []):
            return True, 'LST'  

        if station_code not in self.station_sequences.get(route, []):
            route_stations = [self.get_station_name(code) for code in self.station_sequences[route]]
            return False, f"This station isn't on your {route} route. Please choose from: {', '.join(route_stations)}"  

        return True, station_code 


    #Genrate missing prompts 
    def generate_missing_prompt(self, missing: List[str]) -> str:
        """Generate a prompt for missing fields"""
        prompt = "Could you please provide the "
        missing_items = []
        for field in missing:
            if field == 'origin':
                missing_items.append('departure station')
            elif field == 'destination':
                missing_items.append('destination station')
            elif field == 'date':
                missing_items.append('travel date')
            elif field == 'time':
                missing_items.append('travel time')
            elif field == 'return_date':
                missing_items.append('return date')
            elif field == 'return_time':
                missing_items.append('return time')
        if len(missing_items) == 1:
            prompt += missing_items[0]
        elif len(missing_items) == 2:
            prompt += f"{missing_items[0]} and {missing_items[1]}"
        else:
            prompt += ", ".join(missing_items[:-1]) + f", and {missing_items[-1]}"
        return prompt + "?" 


    #Function validate date
    def validate_date(self, date_str: str) -> bool:
        """Validate date format DD/MM/YYYY or relative date expressions"""
        #Parsing data
        relative_date = self.parse_relative_date(date_str)
        if relative_date:
            return True  

        #Standradatize data fromat 
        try:
            day, month, year = date_str.split('/')
            if len(day) == 2 and len(month) == 2 and len(year) == 4:
                datetime.strptime(date_str, '%d/%m/%Y')
                return True  
        except ValueError:
            return False  
        return False  


    #Function validate time 
    def validate_time(self, time_str: str) -> bool:
        """Validate time format HH:MM"""
        try:
            datetime.strptime(time_str, '%H:%M')
            return True  
        except ValueError:  
            return False  


    #Function for detect route 
    def detect_route(self, text):
        text = text.lower()
        if "norwich" in text and "london" in text:
            if text.find("norwich") < text.find("london"):
                return 'Norwich-LST'  
            return 'LST-Norwich'  
        return None  


    #Function validate direction
    def validate_direction(self, route: str, current: str, destination: str) -> bool:
        """Properly validate travel direction based on actual sequences"""
        try:
            stations = self.station_sequences[route]
            return stations.index(current) < stations.index(destination)  
        except (ValueError, KeyError):
            return False  


    #Detcet intent 
    def detect_intent(self, text: str) -> str:
        processed = self.preprocess_text(text)
        if not processed:
            return "unknown"

        tokens = set(processed)

        #Genral question for the faqs
        qa_triggers = {
    'bike', 'luggage', 'refund', 'miss', 'ticket', 'arrive', 'children', 'travel',
    'platform', 'toilet', 'compensation', 'repay', 'wifi', 'drink', 'seat',
    'pets', 'animal', 'quiet', 'coach', 'charging', 'socket', 'lost', 'property',
    'railcard', 'discount', 'access', 'step-free', 'payment', 'contactless',
    'engineering', 'works', 'tracker', 'delay', 'cancel', 'reservation',
    'schedule', 'timetable', 'early', 'late', 'bag', 'machine'
}

        if tokens & qa_triggers:
            return "general_question"

        #Delay inquires
        delay_triggers = {
            'delay', 'late', 'arriv', 'time', 'status',
            'long', 'when', 'current', 'predict', 'hold',
            'behind', 'schedule', 'timetable', 'due'
        }
        if tokens & delay_triggers:
            #Route mention
            if 'norwich' in tokens and 'london' in tokens:
                return "complex_delay_inquiry"
            return "delay_inquiry"

        #Directions
        greeting_words = {'hello', 'hi', 'hey', 'greet'}
        if tokens & greeting_words:
            return "greeting"

        #Goodbyes 
        farewell_words = {'bye', 'goodbye', 'exit', 'quit', 'farewell'}
        if tokens & farewell_words:
            return "farewell"

        #Booking director
        booking_triggers = {
            'book', 'ticket', 'journey', 'travel', 'train',
            'schedul', 'timet', 'from', 'to', 'depart', 'arriv',
            'go', 'need', 'want', 'would'
        }
        if tokens & booking_triggers:
            return "booking"

        return "unknown"



    #Delay information

    def handle_general_question(self, user_input):
        # Load QnA KB
        with open("qna_kb.json", "r") as f:
            kb = json.load(f)

        best_match = None
        best_score = 0

        for entry in kb:
            score = fuzz.token_sort_ratio(user_input.lower(), entry['question'].lower())
            if score > best_score and score > 75:
                best_score = score
                best_match = entry

        if best_match:
            answer = best_match['answer']
        else:
            #Try reasoning fallback
            self.general_engine = GeneralRuleEngine()
            self.general_engine.reset()
            if "refund" in user_input and "miss" in user_input:
                self.general_engine.declare(Fact(topic="refund", condition="missed_train"))
            elif "bike" in user_input:
                self.general_engine.declare(Fact(topic="bike"))
            self.general_engine.run()
            answer = getattr(self.general_engine, 'response', None)
            if not answer:
                answer = "Sorry, I don't have an answer for that yet."

        #After answering return to options
        self.current_state = self.STATES['GET_OPTION']
        return f"{answer}\n\n{self.options_prompt}"
        
    def get_best_answer(user_question, qa_kb):
        best_match = None
        best_score = 0
        for qa in qa_kb:
            score = fuzz.token_sort_ratio(user_question.lower(), qa["question"].lower())
            if score > best_score:
                best_score = score
                best_match = qa
        return best_match["answer"] if best_score > 75 else "Sorry, I don't have an answer for that."

    def extract_delay_info(self, text: str) -> dict:
        """Extract delay-related information from text"""
        extracted = {}
        text_lower = text.lower()

        #Check for route
        if 'norwich' in text_lower and 'london' in text_lower:
            if text_lower.find('norwich') < text_lower.find('london'):
                extracted['route'] = 'Norwich-LST'
            else:
                extracted['route'] = 'LST-Norwich'

        #Check for delay duration
        delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)s?', text_lower)
        if delay_match:
            extracted['delay'] = int(delay_match.group(1))
            # Convert hours to minutes if needed
            if delay_match.group(2) in ['hour', 'hr']:
                extracted['delay'] *= 60

        #heck for station mentions
        for word in text_lower.split():
            matched_station = self.match_station(word)
            if matched_station:
                if 'current_station' not in extracted:
                    extracted['current_station'] = matched_station
                elif 'destination' not in extracted:
                    extracted['destination'] = matched_station

        return extracted  


    #Delay predictions
    def make_delay_prediction(self) -> str:
        """Generate prediction when all details are available"""
        try:
            route = self.delay_details['route']
            current = self.delay_details['current_station']
            dest = self.delay_details['destination']
            delay = self.delay_details['reported_delay']

            if not self.validate_direction(route, current, dest):
                return ("You appear to be traveling in the wrong direction for this route. "  
                        f"From {self.get_station_name(current)}, you should be heading towards: "
                        f"{', '.join(self.get_station_name(code) for code in self.station_sequences[route][self.station_sequences[route].index(current) + 1:])}")

            rf_prediction = self.delay_predictor.predict(route, current)
            rf_prediction = max(0, rf_prediction) 
            total_delay = delay + rf_prediction

            #Reuse normal travel time logic
            arrival_info = self.predict_arrival(route, current, total_delay, dest)

            self.current_state = self.STATES['GET_OPTION']
            return (  
                f" Based on current data, the predicted delay from {self.get_station_name(current)} is approximately {rf_prediction:.1f} minutes.\n"
                f" Including your reported delay of {delay} minutes, total delay is estimated at {total_delay:.1f} minutes.\n\n"
                f"{arrival_info}\n\n"
                f"{self.options_prompt}"
            )

        except Exception as e:
            return f"Sorry, I couldn't make a prediction: {str(e)}"  

    #Hnadel input for it
    def handle_destination_input(self, user_input: str) -> str:
        is_valid, message = self.validate_station_on_route(
            user_input,
            self.delay_details['route']
        )

        if not is_valid:
            route_stations = self.station_sequences.get(self.delay_details['route'], [])
            suggestions = [
                self.get_station_name(code)
                for code in route_stations
                if user_input.lower() in self.get_station_name(code).lower()
            ]

            if suggestions:
                return f"{message}\nDid you mean: {', '.join(suggestions[:3])}"  
            return message  
        self.delay_details['destination'] = message  
        return self.make_delay_prediction()  


    #Hnadel delays 
    def handle_delay_inquiry(self, user_input: str) -> str:
        """Handle complex delay inquiries with proper validation"""
        if 'norwich' in user_input.lower() and 'london' in user_input.lower():
            if user_input.lower().find('norwich') < user_input.lower().find('london'):
                route = 'Norwich-LST'
            else:
                route = 'LST-Norwich'
        else:
            return "Please specify your route as 'Norwich to London' or 'London to Norwich'" 

        #Dleay minutes extract
        delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)', user_input.lower())
        delay = int(delay_match.group(1)) if delay_match else None

        #Update context
        self.delay_details = {'route': route}
        if delay:
            self.delay_details['reported_delay'] = delay

        #Next question determines
        if not self.delay_details.get('current_station'):
            self.current_state = self.STATES['GET_CURRENT_STATION']
            return "Which station are you currently at?"  
        elif not self.delay_details.get('reported_delay'):
            self.current_state = self.STATES['GET_DELAY_DURATION']
            return "How many minutes delayed is your train?"  
        elif not self.delay_details.get('destination'):
            self.current_state = self.STATES['GET_DESTINATION']
            return "Which station is your destination?"  
        else:
            return self.make_delay_prediction()  

    #Handel delay durations
    def handle_delay_duration(self, user_input: str) -> str:
        """Handle user input for delay duration during delay inquiry"""
        try:
            #Extract delay in minutes from input
            delay_match = re.search(r'(\d+)\s*(minute|min|hour|hr)?', user_input.lower())
            if delay_match:
                delay = int(delay_match.group(1))
                if delay_match.group(2) in ['hour', 'hr']:
                    delay *= 60  #Convert hours to minutes
                self.delay_details['reported_delay'] = delay

                #Ask for destination if not already known
                if not self.delay_details.get('destination'):
                    self.current_state = self.STATES['GET_DESTINATION']
                    return "Which station is your destination?"  
                else:
                    return self.make_delay_prediction()  
            else:
                return "Please enter the delay time in minutes or hours (e.g. '15 minutes', '1 hour')."  
        except Exception as e:
            return f"Sorry, I couldn't understand the delay duration. Error: {str(e)}"  

    #Rsponse generator 
    def generate_response(self, user_input: str) -> str:
        self.log_conversation(user_input, "")

        if not user_input.strip():
            if self.current_state == self.STATES['GET_MISSING_INFO']:
                return "Please provide the missing information: " + self.generate_missing_prompt(self.missing_fields)  
            return "Please provide a valid input."  

        if user_input.lower() == 'ok' and self.current_state == self.STATES['GET_OPTION']:
            return self.options_prompt

        if user_input.lower() in ['go back', 'main menu', 'start over', 'menu']:
            self.booking_details = {k: None for k in self.booking_details}  
            self.current_state = self.STATES['GET_OPTION']
            return "Returning to the main menu...\n\n" + self.options_prompt

        intent = self.detect_intent(user_input)

        #Handle general q and a anytime
        if intent == "general_question" and self.current_state in [
            self.STATES['GET_OPTION'],
            self.STATES['GREETING'],
            self.STATES['FAREWELL']
        ]:
            answer = self.handle_general_question(user_input)
            self.current_state = self.STATES['GET_OPTION']
            return answer
        
        #Farewell at any time
        if intent == "farewell":
            self.current_state = self.STATES['FAREWELL']
            return random.choice(self.farewells)  

        #GREETING OPTIONS
        if self.current_state == self.STATES['GREETING']:
            if intent == "delay_inquiry":
                self.current_state = self.STATES['DELAY_INQUIRY']
                return "I can help with delay predictions. First, which route are you on? (Norwich to London or London to Norwich)"
            else:
                self.current_state = self.STATES['GET_OPTION']
                return f"{random.choice(self.greetings)}\n{self.options_prompt}"  
            



        #Delay or booking flow 
        elif self.current_state == self.STATES['GET_OPTION']:
            if intent == "delay_inquiry" or "2" in user_input:
                self.current_state = self.STATES['DELAY_INQUIRY']
                return "I can help with delay predictions. First, which route are you on? (Norwich to London or London to Norwich)"  
            elif intent == "booking" or "1" in user_input:
                self.current_state = self.STATES['PARSE_BOOKING']
                return "Please tell me about your journey. For example: 'I want to travel from Norwich to London tomorrow at 3pm'"  
            elif "3" in user_input or intent == "farewell":
                self.current_state = self.STATES['FAREWELL']
                return random.choice(self.farewells)  
            else:
                return "I didn't understand that. Please choose:\n1. Book tickets\n2. Check for delays\n3. Ask any other questions\n4. Exit"  

        #Delay inquires
        elif self.current_state == self.STATES['DELAY_INQUIRY']:
            return self.handle_delay_inquiry(user_input)  
        elif self.current_state == self.STATES['GET_CURRENT_STATION']:
            return self.handle_current_station(user_input) 
        elif self.current_state == self.STATES['GET_DELAY_DURATION']:
            return self.handle_delay_duration(user_input)  
        elif self.current_state == self.STATES['GET_DESTINATION']:
            return self.handle_destination_input(user_input) 

        #Prase bookings
        elif self.current_state == self.STATES['PARSE_BOOKING']:
            extracted, missing = self.extract_booking_info(user_input)
            if extracted:
                self.booking_details.update(extracted)
                self.missing_fields = missing
                if not missing:
                    self.current_state = self.STATES['ASK_RETURN']
                    return self.process_booking()
                else:
                    self.current_state = self.STATES['GET_MISSING_INFO']
                    response = "I understood:"
                    if 'origin' in extracted:
                        response += f"\n- From: {self.get_station_name(extracted['origin'])}"
                    if 'destination' in extracted:
                        response += f"\n- To: {self.get_station_name(extracted['destination'])}"
                    if 'date' in extracted:
                        response += f"\n- Date: {extracted['date']}"
                    if 'time' in extracted:
                        response += f"\n- Time: {extracted['time']}"
                    response += "\n\n" + self.generate_missing_prompt(missing)
                    return response  
            return ("I couldn't understand your booking request. "  
                    "Please try something like: 'I want to travel from Norwich to London tomorrow at 3pm'")

        elif self.current_state == self.STATES['GET_MISSING_INFO']:
            extracted, missing = self.extract_booking_info(user_input)
            if extracted:
                for k, v in extracted.items():
                    if v:
                        self.booking_details[k] = v
                self.missing_fields = missing
                if not missing:
                    #Instead of confirming immediately, transition to ask_return if not already handling return
                    if not self.booking_details.get('is_return') and 'return_date' not in self.missing_fields:
                        self.current_state = self.STATES['ASK_RETURN']
                        return self.process_booking()  
                    else:
                        self.booking_details['confirmed'] = True
                        return self.process_booking(confirm=True)  
                else:
                    response = "I understood:"
                    if self.booking_details.get('origin'):
                        response += f"\n- From: {self.get_station_name(self.booking_details['origin'])}"
                    if self.booking_details.get('destination'):
                        response += f"\n- To: {self.get_station_name(self.booking_details['destination'])}"
                    if self.booking_details.get('date'):
                        response += f"\n- Date: {self.booking_details['date']}"
                    if self.booking_details.get('time'):
                        response += f"\n- Time: {self.booking_details['time']}"
                    response += "\n\n" + self.generate_missing_prompt(missing)
                    return response  
            return "Please provide the missing information: " + self.generate_missing_prompt(self.missing_fields)  

        #ASK_RETURN is single handler only
        elif self.current_state == self.STATES['ASK_RETURN']:
            user_input_lower = user_input.lower().strip()
            if user_input_lower in ['yes', 'y']:
                self.booking_details['is_return'] = True
                self.expecting_return_time = True 
                self.current_state = self.STATES['GET_MISSING_INFO']
                self.missing_fields = ['return_date', 'return_time']
                return "Sure—please provide your return date and time (e.g. 'June 6th at 4pm')" 
            elif user_input_lower in ['no', 'n']:
                self.booking_details['is_return'] = False

                self.booking_details['return_date'] = None
                self.booking_details['return_time'] = None
                self.booking_details['return_depart_type'] = None
                self.booking_details['return_time_preference'] = None
                self.booking_details['confirmed'] = True
                return self.process_booking(confirm=True)  
            else:
                return "Please answer 'yes' or 'no' to whether you want a return ticket."  

        # FAREWELL state
        elif self.current_state == self.STATES['FAREWELL']:
            if user_input.lower() in ['menu', 'options', 'back']:
                self.current_state = self.STATES['GET_OPTION']
                return self.options_prompt  
            return random.choice(self.farewells) 
        # Catch-all
        return "Sorry, I didn't understand that."  


    #Handel current station
    def handle_current_station(self, user_input: str) -> str:
        """Handle input for current station during delay prediction flow"""
        is_valid, message = self.validate_station_on_route(
            user_input,
            self.delay_details['route']
        )

        if not is_valid:
            suggestions = self.generate_station_suggestions(user_input, self.delay_details['route'])
            if suggestions:
                return f"{message}\nDid you mean: {', '.join(suggestions[:3])}?"  
            return message  

        self.delay_details['current_station'] = message  

        #Ask for next piece of info
        if not self.delay_details.get('reported_delay'):
            self.current_state = self.STATES['GET_DELAY_DURATION']
            return "How many minutes delayed is your train?"  
        elif not self.delay_details.get('destination'):
            self.current_state = self.STATES['GET_DESTINATION']
            return "Which station is your destination?"  
        else:
            return self.make_delay_prediction()  


    #processing booking
    def process_booking(self, confirm=False):
        if not self.booking_details.get('date'):
            self.booking_details['date'] = (datetime.now() + timedelta(days=1)).strftime('%d/%m/%Y')

        summary = "Here's your journey summary:\n"
        summary += f"From: {self.get_station_name(self.booking_details['origin'])}\n"
        summary += f"To: {self.get_station_name(self.booking_details['destination'])}\n"
        summary += f"Date: {self.booking_details['date']}\n"
        time_label = "Arrive by" if self.booking_details['time_preference'] == 'by' else "Depart after"
        summary += f"{time_label}: {self.booking_details['time']}\n"
        summary += f"Adults: {self.booking_details['adults']}\n"
        summary += f"Children: {self.booking_details['children']}\n"

        if self.booking_details.get('return_date') and self.booking_details.get('return_time'):
            summary += f"Return Date: {self.booking_details['return_date']}\n"
            summary += f"Return Time: {self.booking_details['return_time']}\n"

        if confirm:
            try:
                result = compare_ticket_prices(
                    origin=self.booking_details['origin'],
                    destination=self.booking_details['destination'],
                    depart_date=self.booking_details['date'],
                    depart_time=self.booking_details['time'],
                    depart_type=self.booking_details['depart_type'],
                    time_preference=self.booking_details['time_preference'],
                    is_return=self.booking_details.get('is_return', False),
                    return_date=self.booking_details['return_date'],
                    return_time=self.booking_details['return_time'],
                    return_type=self.booking_details['depart_type'],
                    adults=self.booking_details['adults'],
                    children=self.booking_details['children']
                )

                summary += "\n\nTicket Comparison:\n"
                if result['national_rail']['total_price'] is not None:
                    summary += f" National Rail: £{result['national_rail']['total_price']:.2f} → {result['national_rail']['url']}\n"
                else:
                    summary += "National Rail: No result found.\n"

                if result['thameslink']['total_price'] is not None:
                    summary += f"Thameslink: £{result['thameslink']['total_price']:.2f} → {result['thameslink']['url']}\n"
                else:
                    summary += "Thameslink: No result found.\n"

                summary += f"\nVerdict: {result['verdict']}"
                self.current_state = self.STATES['GET_OPTION']
                return summary + f"\n\n{self.options_prompt}" 

            except Exception as e:
                return f" Error during ticket search: {str(e)}"  

        if not self.booking_details.get('is_return'):
            self.current_state = self.STATES['ASK_RETURN']
            return summary + "\nWould you like to book a return ticket? (yes/no)" 

        return summary + "\nPlease provide your return date and time (e.g. 'June 6th at 4pm')" 


    #Normal time calculated 
    def calculate_normal_travel_times(self, route):
        """Calculate normal travel times between stations for a route"""
        if route not in self.delay_data or not isinstance(self.delay_data[route], pd.DataFrame):
            return None  

        df = self.delay_data[route].copy()
        normal_times = {}

        #Decete times auto
        time_cols = {'arrival': None, 'departure': None}

        #Common column name patterns to check
        arrival_patterns = ['arrival', 'pta', 'planned_arrival']
        departure_patterns = ['departure', 'ptd', 'planned_departure']

        #Try to find matching columns
        for col in df.columns:
            col_lower = col.lower()
            if not time_cols['arrival'] and any(pattern in col_lower for pattern in arrival_patterns):
                time_cols['arrival'] = col
            if not time_cols['departure'] and any(pattern in col_lower for pattern in departure_patterns):
                time_cols['departure'] = col

        #If we couldn't find columns then use hardcoded defaults based on route
        if not time_cols['arrival'] or not time_cols['departure']:
            if route == 'Norwich-LST':
                time_cols = {
                    'arrival': 'planned_arrival_time',
                    'departure': 'planned_departure_time'
                }
            else:  # LST-Norwich
                time_cols = {
                    'arrival': 'gbtt_pta',
                    'departure': 'gbtt_ptd'
                }

        #Check if the required columns exist
        missing_cols = [col for col in time_cols.values() if col not in df.columns]
        if missing_cols:
            print(f"Warning: Could not find time columns in {route} data. Tried: {time_cols}") 
            print(f"Actual columns: {df.columns.tolist()}") 
            return None  # Return result
        for col in time_cols.values():

            df[col] = df[col].astype(str)

            df[col] = pd.to_datetime(df[col], format='%H:%M', errors='coerce').dt.time

        stations = self.station_sequences[route]

        for i in range(len(stations) - 1):
            from_stn = stations[i]
            to_stn = stations[i + 1]

            #Get all services between these stations
            from_df = df[df['location'] == from_stn]
            to_df = df[df['location'] == to_stn]

            #Merge on rid and date_of_service to match the same train
            merged = pd.merge(
                from_df[['rid', 'date_of_service', time_cols['departure']]].rename(
                    columns={time_cols['departure']: 'departure_time'}),
                to_df[['rid', 'date_of_service', time_cols['arrival']]].rename(
                    columns={time_cols['arrival']: 'arrival_time'}),
                on=['rid', 'date_of_service'],
                suffixes=('_from', '_to')
            )

            if not merged.empty:

    #Time calculation
                def calculate_time(row):
                    try:
                        dep_time = row['departure_time']
                        arr_time = row['arrival_time']

                        if pd.isna(dep_time) or pd.isna(arr_time):
                            return np.nan 

                        #Create datetime objects for calculation
                        dep_dt = datetime.combine(datetime.today(), dep_time)
                        arr_dt = datetime.combine(datetime.today(), arr_time)

                        #Handle overnight trains (negative time difference)
                        if arr_dt < dep_dt:
                            arr_dt += timedelta(days=1)

                        return (arr_dt - dep_dt).total_seconds() / 60  
                    except Exception as e:
                        print(f"Error calculating time: {e}")  
                        return np.nan  

                merged['travel_time'] = merged.apply(calculate_time, axis=1)

                #Drop rows with invalid times
                merged = merged.dropna(subset=['travel_time'])

                if not merged.empty:
                    #Store median travel time
                    normal_times[(from_stn, to_stn)] = merged['travel_time'].median()
                    print(f"Normal time {from_stn}->{to_stn}: {normal_times[(from_stn, to_stn)]:.1f} minutes")  
                else:
                    print(f"No valid time data for {from_stn}->{to_stn}")  
                    normal_times[(from_stn, to_stn)] = 30  
            else:
                print(f"No matching services for {from_stn}->{to_stn}")  
                normal_times[(from_stn, to_stn)] = 30 

        return normal_times  


    #Predistion arrival 
    def predict_arrival(self, route, current_station, delay, destination):
        """Predict arrival time with fallback behavior"""
        normal_times = self.normal_travel_times.get(route, {})
        stations = self.station_sequences.get(route, [])

        if not normal_times:
            print(f"Warning: No normal travel times available for route {route}") 
            #Create default normal times
            normal_times = {(stations[i], stations[i + 1]): 30
                            for i in range(len(stations) - 1)}

        if current_station not in stations or destination not in stations:
            print(f"Warning: Stations not in route {route}")  
            return None

        current_idx = stations.index(current_station)
        dest_idx = stations.index(destination)

        #Calculate normal travel time
        normal_travel_time = 0
        for i in range(current_idx, dest_idx):
            from_stn = stations[i]
            to_stn = stations[i + 1]
            pair = (from_stn, to_stn)
            normal_travel_time += normal_times.get(pair, 30)  

        #Add the reported delay
        total_time = normal_travel_time + delay
        now = datetime.now()
        estimated_arrival = now + timedelta(minutes=total_time)
        #Format the output
        output = (
            f"Normally this journey takes {normal_travel_time:.1f} minutes.\n"
            f"With your {delay} minute delay, the total expected travel time is {total_time:.1f} minutes.\n"
            f"Estimated arrival time: {estimated_arrival.strftime('%H:%M')}"
        )

        return output  


    #Calcuate schedule time 
    def calculate_schedule_times(self, route, stations):
        """Calculate typical schedule times between stations"""
        if route not in self.delay_data or not isinstance(self.delay_data[route], pd.DataFrame):
            return None  

        df = self.delay_data[route]
        schedule_times = [0] 

        for i in range(1, len(stations)):
            from_stn = stations[i - 1]
            to_stn = stations[i]

            #Get typical travel time between these stations
            mask = (df['location'] == from_stn)
            departures = df[mask]['actual_departure'].dropna()

            mask = (df['location'] == to_stn)
            arrivals = df[mask]['actual_arrival'].dropna()

            if not departures.empty and not arrivals.empty:
                #Convert times to minutes since midnight for calculation
                departures_min = departures.apply(lambda x: x.hour * 60 + x.minute)
                arrivals_min = arrivals.apply(lambda x: x.hour * 60 + x.minute)

                #Calculate median travel time in minutes
                typical_time = (arrivals_min.median() - departures_min.median())

                #Handle overnight trains (negative time difference)
                if typical_time < 0:
                    typical_time += 1440  # Add 24 hours in minutes

                schedule_times.append(schedule_times[-1] + typical_time)
            else:
                #Fallback: use 30 minutes between stations if no data
                schedule_times.append(schedule_times[-1] + 30)

        return schedule_times  

#Main running fuction
if __name__ == "__main__":
    print("Initializing Train Ticket Chatbot...")  
    chatbot = TrainTicketChatbotWithBooking()
    print("\nLoading and analyzing delay data...")  
    chatbot.load_delay_data()
    print("\nWelcome to TrainBot! Type 'exit' to quit at any time.")  
    while True:
        user_input = input("\nYou: ").strip()
        if user_input.lower() in ['exit', 'quit', 'bye', 'goodbye']:
            print("TrainBot:", random.choice(chatbot.farewells))  
            break
        response = chatbot.generate_response(user_input)
        print("TrainBot:", response)  
